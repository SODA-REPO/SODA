{"message":"feature has been removed","code":{"code":"E0557","explanation":"A feature attribute named a feature that has been removed.\n\nErroneous code example:\n\n```compile_fail,E0557\n#![feature(managed_boxes)] // error: feature has been removed\n```\n\nDelete the offending feature attribute.\n"},"level":"error","spans":[{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/lib.rs","byte_start":7509,"byte_end":7517,"line_start":204,"line_end":204,"column_start":5,"column_end":13,"is_primary":true,"text":[{"text":"    const_fn,","highlight_start":5,"highlight_end":13}],"label":"feature has been removed","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"split into finer-grained feature gates","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0557]\u001b[0m\u001b[0m\u001b[1m: feature has been removed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/lib.rs:204:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m204\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const_fn,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mfeature has been removed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: split into finer-grained feature gates\u001b[0m\n\n"}
{"message":"unresolved import `crate::arch::x86_64::_mm_movemask_pi8`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018, paths in `use` statements are relative to the current module\nunless they begin with the name of a crate or a literal `crate::`, in which\ncase they start from the crate root. As in Rust 2015 code, the `self::` and\n`super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nIn Rust 2018 the `extern crate` declaration is not required and you can instead\njust `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs","byte_start":1701,"byte_end":1738,"line_start":47,"line_end":47,"column_start":21,"column_end":58,"is_primary":true,"text":[{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":21,"highlight_end":58}],"label":"no `_mm_movemask_pi8` in `core_arch::arch::x86_64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":483,"byte_end":506,"line_start":24,"line_end":24,"column_start":17,"column_end":40,"is_primary":false,"text":[{"text":"                x86_m8x8_sse_impl!($id);","highlight_start":17,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":3485,"byte_end":3505,"line_start":143,"line_end":143,"column_start":17,"column_end":37,"is_primary":false,"text":[{"text":"    (m8x8) => { x86_m8x8_impl!(m8x8); };","highlight_start":17,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask.rs","byte_start":988,"byte_end":1015,"line_start":41,"line_end":41,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"impl_mask_reductions!(m8x8);","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_mask_reductions!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":3408,"byte_end":5371,"line_start":141,"line_end":194,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_mask_reductions {","highlight_start":1,"highlight_end":36},{"text":"    // 64-bit wide masks","highlight_start":1,"highlight_end":25},{"text":"    (m8x8) => { x86_m8x8_impl!(m8x8); };","highlight_start":1,"highlight_end":41},{"text":"    (m16x4) => { x86_m8x8_impl!(m16x4); };","highlight_start":1,"highlight_end":43},{"text":"    (m32x2) => { x86_m8x8_impl!(m32x2); };","highlight_start":1,"highlight_end":43},{"text":"    // 128-bit wide masks","highlight_start":1,"highlight_end":26},{"text":"    (m8x16) => { x86_m8x16_impl!(m8x16); };","highlight_start":1,"highlight_end":44},{"text":"    (m16x8) => { x86_m8x16_impl!(m16x8); };","highlight_start":1,"highlight_end":44},{"text":"    (m32x4) => { x86_m32x4_impl!(m32x4); };","highlight_start":1,"highlight_end":44},{"text":"    (m64x2) => { x86_m64x2_impl!(m64x2); };","highlight_start":1,"highlight_end":44},{"text":"    (m128x1) => { x86_intr_impl!(m128x1); };","highlight_start":1,"highlight_end":45},{"text":"    // 256-bit wide masks:","highlight_start":1,"highlight_end":27},{"text":"    (m8x32) => { x86_m8x32_impl!(m8x32, m8x16); };","highlight_start":1,"highlight_end":51},{"text":"    (m16x16) => { x86_m8x32_impl!(m16x16, m16x8); };","highlight_start":1,"highlight_end":53},{"text":"    (m32x8) => { x86_m32x8_impl!(m32x8, m32x4); };","highlight_start":1,"highlight_end":51},{"text":"    (m64x4) => { x86_m64x4_impl!(m64x4, m64x2); };","highlight_start":1,"highlight_end":51},{"text":"    (m128x2) => { x86_intr_impl!(m128x2); };","highlight_start":1,"highlight_end":45},{"text":"    (msizex2) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex2, m64x2);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex2, m32x2);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (msizex4) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex4, m64x4);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex4, m32x4);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (msizex8) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex8, m64x8);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex8, m32x8);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Fallback to LLVM's default code-generation:","highlight_start":1,"highlight_end":51},{"text":"    ($id:ident) => { fallback_impl!($id); };","highlight_start":1,"highlight_end":45},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"x86_m8x8_impl!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":322,"byte_end":598,"line_start":20,"line_end":30,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! x86_m8x8_impl {","highlight_start":1,"highlight_end":29},{"text":"    ($id:ident) => {","highlight_start":1,"highlight_end":21},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(all(target_arch = \"x86_64\", target_feature = \"sse\"))] {","highlight_start":1,"highlight_end":77},{"text":"                x86_m8x8_sse_impl!($id);","highlight_start":1,"highlight_end":41},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                fallback_impl!($id);","highlight_start":1,"highlight_end":37},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"x86_m8x8_sse_impl!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs","byte_start":1343,"byte_end":2530,"line_start":38,"line_end":68,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! x86_m8x8_sse_impl {","highlight_start":1,"highlight_end":33},{"text":"    ($id:ident) => {","highlight_start":1,"highlight_end":21},{"text":"        impl All for $id {","highlight_start":1,"highlight_end":27},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            #[target_feature(enable = \"sse\")]","highlight_start":1,"highlight_end":46},{"text":"            unsafe fn all(self) -> bool {","highlight_start":1,"highlight_end":42},{"text":"                #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":44},{"text":"                use crate::arch::x86::_mm_movemask_pi8;","highlight_start":1,"highlight_end":56},{"text":"                #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":47},{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":1,"highlight_end":59},{"text":"                // _mm_movemask_pi8(a) creates an 8bit mask containing the most","highlight_start":1,"highlight_end":80},{"text":"                // significant bit of each byte of `a`. If all bits are set,","highlight_start":1,"highlight_end":77},{"text":"                // then all 8 lanes of the mask are true.","highlight_start":1,"highlight_end":58},{"text":"                _mm_movemask_pi8(crate::mem::transmute(self))","highlight_start":1,"highlight_end":62},{"text":"                    == u8::max_value() as i32","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        impl Any for $id {","highlight_start":1,"highlight_end":27},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            #[target_feature(enable = \"sse\")]","highlight_start":1,"highlight_end":46},{"text":"            unsafe fn any(self) -> bool {","highlight_start":1,"highlight_end":42},{"text":"                #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":44},{"text":"                use crate::arch::x86::_mm_movemask_pi8;","highlight_start":1,"highlight_end":56},{"text":"                #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":47},{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":1,"highlight_end":59},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                _mm_movemask_pi8(crate::mem::transmute(self)) != 0","highlight_start":1,"highlight_end":67},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"a similar name exists in the module","code":null,"level":"help","spans":[{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs","byte_start":1722,"byte_end":1738,"line_start":47,"line_end":47,"column_start":42,"column_end":58,"is_primary":true,"text":[{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":42,"highlight_end":58}],"label":null,"suggested_replacement":"_mm_movemask_epi8","suggestion_applicability":"MaybeIncorrect","expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":483,"byte_end":506,"line_start":24,"line_end":24,"column_start":17,"column_end":40,"is_primary":false,"text":[{"text":"                x86_m8x8_sse_impl!($id);","highlight_start":17,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":3485,"byte_end":3505,"line_start":143,"line_end":143,"column_start":17,"column_end":37,"is_primary":false,"text":[{"text":"    (m8x8) => { x86_m8x8_impl!(m8x8); };","highlight_start":17,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask.rs","byte_start":988,"byte_end":1015,"line_start":41,"line_end":41,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"impl_mask_reductions!(m8x8);","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_mask_reductions!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":3408,"byte_end":5371,"line_start":141,"line_end":194,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_mask_reductions {","highlight_start":1,"highlight_end":36},{"text":"    // 64-bit wide masks","highlight_start":1,"highlight_end":25},{"text":"    (m8x8) => { x86_m8x8_impl!(m8x8); };","highlight_start":1,"highlight_end":41},{"text":"    (m16x4) => { x86_m8x8_impl!(m16x4); };","highlight_start":1,"highlight_end":43},{"text":"    (m32x2) => { x86_m8x8_impl!(m32x2); };","highlight_start":1,"highlight_end":43},{"text":"    // 128-bit wide masks","highlight_start":1,"highlight_end":26},{"text":"    (m8x16) => { x86_m8x16_impl!(m8x16); };","highlight_start":1,"highlight_end":44},{"text":"    (m16x8) => { x86_m8x16_impl!(m16x8); };","highlight_start":1,"highlight_end":44},{"text":"    (m32x4) => { x86_m32x4_impl!(m32x4); };","highlight_start":1,"highlight_end":44},{"text":"    (m64x2) => { x86_m64x2_impl!(m64x2); };","highlight_start":1,"highlight_end":44},{"text":"    (m128x1) => { x86_intr_impl!(m128x1); };","highlight_start":1,"highlight_end":45},{"text":"    // 256-bit wide masks:","highlight_start":1,"highlight_end":27},{"text":"    (m8x32) => { x86_m8x32_impl!(m8x32, m8x16); };","highlight_start":1,"highlight_end":51},{"text":"    (m16x16) => { x86_m8x32_impl!(m16x16, m16x8); };","highlight_start":1,"highlight_end":53},{"text":"    (m32x8) => { x86_m32x8_impl!(m32x8, m32x4); };","highlight_start":1,"highlight_end":51},{"text":"    (m64x4) => { x86_m64x4_impl!(m64x4, m64x2); };","highlight_start":1,"highlight_end":51},{"text":"    (m128x2) => { x86_intr_impl!(m128x2); };","highlight_start":1,"highlight_end":45},{"text":"    (msizex2) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex2, m64x2);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex2, m32x2);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (msizex4) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex4, m64x4);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex4, m32x4);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (msizex8) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex8, m64x8);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex8, m32x8);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Fallback to LLVM's default code-generation:","highlight_start":1,"highlight_end":51},{"text":"    ($id:ident) => { fallback_impl!($id); };","highlight_start":1,"highlight_end":45},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"x86_m8x8_impl!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":322,"byte_end":598,"line_start":20,"line_end":30,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! x86_m8x8_impl {","highlight_start":1,"highlight_end":29},{"text":"    ($id:ident) => {","highlight_start":1,"highlight_end":21},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(all(target_arch = \"x86_64\", target_feature = \"sse\"))] {","highlight_start":1,"highlight_end":77},{"text":"                x86_m8x8_sse_impl!($id);","highlight_start":1,"highlight_end":41},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                fallback_impl!($id);","highlight_start":1,"highlight_end":37},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"x86_m8x8_sse_impl!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs","byte_start":1343,"byte_end":2530,"line_start":38,"line_end":68,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! x86_m8x8_sse_impl {","highlight_start":1,"highlight_end":33},{"text":"    ($id:ident) => {","highlight_start":1,"highlight_end":21},{"text":"        impl All for $id {","highlight_start":1,"highlight_end":27},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            #[target_feature(enable = \"sse\")]","highlight_start":1,"highlight_end":46},{"text":"            unsafe fn all(self) -> bool {","highlight_start":1,"highlight_end":42},{"text":"                #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":44},{"text":"                use crate::arch::x86::_mm_movemask_pi8;","highlight_start":1,"highlight_end":56},{"text":"                #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":47},{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":1,"highlight_end":59},{"text":"                // _mm_movemask_pi8(a) creates an 8bit mask containing the most","highlight_start":1,"highlight_end":80},{"text":"                // significant bit of each byte of `a`. If all bits are set,","highlight_start":1,"highlight_end":77},{"text":"                // then all 8 lanes of the mask are true.","highlight_start":1,"highlight_end":58},{"text":"                _mm_movemask_pi8(crate::mem::transmute(self))","highlight_start":1,"highlight_end":62},{"text":"                    == u8::max_value() as i32","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        impl Any for $id {","highlight_start":1,"highlight_end":27},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            #[target_feature(enable = \"sse\")]","highlight_start":1,"highlight_end":46},{"text":"            unsafe fn any(self) -> bool {","highlight_start":1,"highlight_end":42},{"text":"                #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":44},{"text":"                use crate::arch::x86::_mm_movemask_pi8;","highlight_start":1,"highlight_end":56},{"text":"                #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":47},{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":1,"highlight_end":59},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                _mm_movemask_pi8(crate::mem::transmute(self)) != 0","highlight_start":1,"highlight_end":67},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m\u001b[1m: unresolved import `crate::arch::x86_64::_mm_movemask_pi8`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs:47:21\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                use crate::arch::x86_64::_mm_movemask_pi8;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: a similar name exists in the module: `_mm_movemask_epi8`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno `_mm_movemask_pi8` in `core_arch::arch::x86_64`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask.rs:41:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m41\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mimpl_mask_reductions!(m8x8);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `x86_m8x8_sse_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"unresolved import `crate::arch::x86_64::_mm_movemask_pi8`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018, paths in `use` statements are relative to the current module\nunless they begin with the name of a crate or a literal `crate::`, in which\ncase they start from the crate root. As in Rust 2015 code, the `self::` and\n`super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nIn Rust 2018 the `extern crate` declaration is not required and you can instead\njust `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs","byte_start":2391,"byte_end":2428,"line_start":62,"line_end":62,"column_start":21,"column_end":58,"is_primary":true,"text":[{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":21,"highlight_end":58}],"label":"no `_mm_movemask_pi8` in `core_arch::arch::x86_64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":483,"byte_end":506,"line_start":24,"line_end":24,"column_start":17,"column_end":40,"is_primary":false,"text":[{"text":"                x86_m8x8_sse_impl!($id);","highlight_start":17,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":3485,"byte_end":3505,"line_start":143,"line_end":143,"column_start":17,"column_end":37,"is_primary":false,"text":[{"text":"    (m8x8) => { x86_m8x8_impl!(m8x8); };","highlight_start":17,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask.rs","byte_start":988,"byte_end":1015,"line_start":41,"line_end":41,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"impl_mask_reductions!(m8x8);","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_mask_reductions!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":3408,"byte_end":5371,"line_start":141,"line_end":194,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_mask_reductions {","highlight_start":1,"highlight_end":36},{"text":"    // 64-bit wide masks","highlight_start":1,"highlight_end":25},{"text":"    (m8x8) => { x86_m8x8_impl!(m8x8); };","highlight_start":1,"highlight_end":41},{"text":"    (m16x4) => { x86_m8x8_impl!(m16x4); };","highlight_start":1,"highlight_end":43},{"text":"    (m32x2) => { x86_m8x8_impl!(m32x2); };","highlight_start":1,"highlight_end":43},{"text":"    // 128-bit wide masks","highlight_start":1,"highlight_end":26},{"text":"    (m8x16) => { x86_m8x16_impl!(m8x16); };","highlight_start":1,"highlight_end":44},{"text":"    (m16x8) => { x86_m8x16_impl!(m16x8); };","highlight_start":1,"highlight_end":44},{"text":"    (m32x4) => { x86_m32x4_impl!(m32x4); };","highlight_start":1,"highlight_end":44},{"text":"    (m64x2) => { x86_m64x2_impl!(m64x2); };","highlight_start":1,"highlight_end":44},{"text":"    (m128x1) => { x86_intr_impl!(m128x1); };","highlight_start":1,"highlight_end":45},{"text":"    // 256-bit wide masks:","highlight_start":1,"highlight_end":27},{"text":"    (m8x32) => { x86_m8x32_impl!(m8x32, m8x16); };","highlight_start":1,"highlight_end":51},{"text":"    (m16x16) => { x86_m8x32_impl!(m16x16, m16x8); };","highlight_start":1,"highlight_end":53},{"text":"    (m32x8) => { x86_m32x8_impl!(m32x8, m32x4); };","highlight_start":1,"highlight_end":51},{"text":"    (m64x4) => { x86_m64x4_impl!(m64x4, m64x2); };","highlight_start":1,"highlight_end":51},{"text":"    (m128x2) => { x86_intr_impl!(m128x2); };","highlight_start":1,"highlight_end":45},{"text":"    (msizex2) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex2, m64x2);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex2, m32x2);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (msizex4) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex4, m64x4);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex4, m32x4);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (msizex8) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex8, m64x8);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex8, m32x8);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Fallback to LLVM's default code-generation:","highlight_start":1,"highlight_end":51},{"text":"    ($id:ident) => { fallback_impl!($id); };","highlight_start":1,"highlight_end":45},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"x86_m8x8_impl!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":322,"byte_end":598,"line_start":20,"line_end":30,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! x86_m8x8_impl {","highlight_start":1,"highlight_end":29},{"text":"    ($id:ident) => {","highlight_start":1,"highlight_end":21},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(all(target_arch = \"x86_64\", target_feature = \"sse\"))] {","highlight_start":1,"highlight_end":77},{"text":"                x86_m8x8_sse_impl!($id);","highlight_start":1,"highlight_end":41},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                fallback_impl!($id);","highlight_start":1,"highlight_end":37},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"x86_m8x8_sse_impl!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs","byte_start":1343,"byte_end":2530,"line_start":38,"line_end":68,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! x86_m8x8_sse_impl {","highlight_start":1,"highlight_end":33},{"text":"    ($id:ident) => {","highlight_start":1,"highlight_end":21},{"text":"        impl All for $id {","highlight_start":1,"highlight_end":27},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            #[target_feature(enable = \"sse\")]","highlight_start":1,"highlight_end":46},{"text":"            unsafe fn all(self) -> bool {","highlight_start":1,"highlight_end":42},{"text":"                #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":44},{"text":"                use crate::arch::x86::_mm_movemask_pi8;","highlight_start":1,"highlight_end":56},{"text":"                #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":47},{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":1,"highlight_end":59},{"text":"                // _mm_movemask_pi8(a) creates an 8bit mask containing the most","highlight_start":1,"highlight_end":80},{"text":"                // significant bit of each byte of `a`. If all bits are set,","highlight_start":1,"highlight_end":77},{"text":"                // then all 8 lanes of the mask are true.","highlight_start":1,"highlight_end":58},{"text":"                _mm_movemask_pi8(crate::mem::transmute(self))","highlight_start":1,"highlight_end":62},{"text":"                    == u8::max_value() as i32","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        impl Any for $id {","highlight_start":1,"highlight_end":27},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            #[target_feature(enable = \"sse\")]","highlight_start":1,"highlight_end":46},{"text":"            unsafe fn any(self) -> bool {","highlight_start":1,"highlight_end":42},{"text":"                #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":44},{"text":"                use crate::arch::x86::_mm_movemask_pi8;","highlight_start":1,"highlight_end":56},{"text":"                #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":47},{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":1,"highlight_end":59},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                _mm_movemask_pi8(crate::mem::transmute(self)) != 0","highlight_start":1,"highlight_end":67},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"a similar name exists in the module","code":null,"level":"help","spans":[{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs","byte_start":2412,"byte_end":2428,"line_start":62,"line_end":62,"column_start":42,"column_end":58,"is_primary":true,"text":[{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":42,"highlight_end":58}],"label":null,"suggested_replacement":"_mm_movemask_epi8","suggestion_applicability":"MaybeIncorrect","expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":483,"byte_end":506,"line_start":24,"line_end":24,"column_start":17,"column_end":40,"is_primary":false,"text":[{"text":"                x86_m8x8_sse_impl!($id);","highlight_start":17,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":3485,"byte_end":3505,"line_start":143,"line_end":143,"column_start":17,"column_end":37,"is_primary":false,"text":[{"text":"    (m8x8) => { x86_m8x8_impl!(m8x8); };","highlight_start":17,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask.rs","byte_start":988,"byte_end":1015,"line_start":41,"line_end":41,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"impl_mask_reductions!(m8x8);","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_mask_reductions!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":3408,"byte_end":5371,"line_start":141,"line_end":194,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_mask_reductions {","highlight_start":1,"highlight_end":36},{"text":"    // 64-bit wide masks","highlight_start":1,"highlight_end":25},{"text":"    (m8x8) => { x86_m8x8_impl!(m8x8); };","highlight_start":1,"highlight_end":41},{"text":"    (m16x4) => { x86_m8x8_impl!(m16x4); };","highlight_start":1,"highlight_end":43},{"text":"    (m32x2) => { x86_m8x8_impl!(m32x2); };","highlight_start":1,"highlight_end":43},{"text":"    // 128-bit wide masks","highlight_start":1,"highlight_end":26},{"text":"    (m8x16) => { x86_m8x16_impl!(m8x16); };","highlight_start":1,"highlight_end":44},{"text":"    (m16x8) => { x86_m8x16_impl!(m16x8); };","highlight_start":1,"highlight_end":44},{"text":"    (m32x4) => { x86_m32x4_impl!(m32x4); };","highlight_start":1,"highlight_end":44},{"text":"    (m64x2) => { x86_m64x2_impl!(m64x2); };","highlight_start":1,"highlight_end":44},{"text":"    (m128x1) => { x86_intr_impl!(m128x1); };","highlight_start":1,"highlight_end":45},{"text":"    // 256-bit wide masks:","highlight_start":1,"highlight_end":27},{"text":"    (m8x32) => { x86_m8x32_impl!(m8x32, m8x16); };","highlight_start":1,"highlight_end":51},{"text":"    (m16x16) => { x86_m8x32_impl!(m16x16, m16x8); };","highlight_start":1,"highlight_end":53},{"text":"    (m32x8) => { x86_m32x8_impl!(m32x8, m32x4); };","highlight_start":1,"highlight_end":51},{"text":"    (m64x4) => { x86_m64x4_impl!(m64x4, m64x2); };","highlight_start":1,"highlight_end":51},{"text":"    (m128x2) => { x86_intr_impl!(m128x2); };","highlight_start":1,"highlight_end":45},{"text":"    (msizex2) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex2, m64x2);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex2, m32x2);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (msizex4) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex4, m64x4);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex4, m32x4);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (msizex8) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex8, m64x8);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex8, m32x8);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Fallback to LLVM's default code-generation:","highlight_start":1,"highlight_end":51},{"text":"    ($id:ident) => { fallback_impl!($id); };","highlight_start":1,"highlight_end":45},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"x86_m8x8_impl!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":322,"byte_end":598,"line_start":20,"line_end":30,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! x86_m8x8_impl {","highlight_start":1,"highlight_end":29},{"text":"    ($id:ident) => {","highlight_start":1,"highlight_end":21},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(all(target_arch = \"x86_64\", target_feature = \"sse\"))] {","highlight_start":1,"highlight_end":77},{"text":"                x86_m8x8_sse_impl!($id);","highlight_start":1,"highlight_end":41},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                fallback_impl!($id);","highlight_start":1,"highlight_end":37},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"x86_m8x8_sse_impl!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs","byte_start":1343,"byte_end":2530,"line_start":38,"line_end":68,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! x86_m8x8_sse_impl {","highlight_start":1,"highlight_end":33},{"text":"    ($id:ident) => {","highlight_start":1,"highlight_end":21},{"text":"        impl All for $id {","highlight_start":1,"highlight_end":27},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            #[target_feature(enable = \"sse\")]","highlight_start":1,"highlight_end":46},{"text":"            unsafe fn all(self) -> bool {","highlight_start":1,"highlight_end":42},{"text":"                #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":44},{"text":"                use crate::arch::x86::_mm_movemask_pi8;","highlight_start":1,"highlight_end":56},{"text":"                #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":47},{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":1,"highlight_end":59},{"text":"                // _mm_movemask_pi8(a) creates an 8bit mask containing the most","highlight_start":1,"highlight_end":80},{"text":"                // significant bit of each byte of `a`. If all bits are set,","highlight_start":1,"highlight_end":77},{"text":"                // then all 8 lanes of the mask are true.","highlight_start":1,"highlight_end":58},{"text":"                _mm_movemask_pi8(crate::mem::transmute(self))","highlight_start":1,"highlight_end":62},{"text":"                    == u8::max_value() as i32","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        impl Any for $id {","highlight_start":1,"highlight_end":27},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            #[target_feature(enable = \"sse\")]","highlight_start":1,"highlight_end":46},{"text":"            unsafe fn any(self) -> bool {","highlight_start":1,"highlight_end":42},{"text":"                #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":44},{"text":"                use crate::arch::x86::_mm_movemask_pi8;","highlight_start":1,"highlight_end":56},{"text":"                #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":47},{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":1,"highlight_end":59},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                _mm_movemask_pi8(crate::mem::transmute(self)) != 0","highlight_start":1,"highlight_end":67},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m\u001b[1m: unresolved import `crate::arch::x86_64::_mm_movemask_pi8`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs:62:21\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m62\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                use crate::arch::x86_64::_mm_movemask_pi8;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: a similar name exists in the module: `_mm_movemask_epi8`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno `_mm_movemask_pi8` in `core_arch::arch::x86_64`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask.rs:41:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m41\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mimpl_mask_reductions!(m8x8);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `x86_m8x8_sse_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"unresolved import `crate::arch::x86_64::_mm_movemask_pi8`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018, paths in `use` statements are relative to the current module\nunless they begin with the name of a crate or a literal `crate::`, in which\ncase they start from the crate root. As in Rust 2015 code, the `self::` and\n`super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nIn Rust 2018 the `extern crate` declaration is not required and you can instead\njust `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs","byte_start":1701,"byte_end":1738,"line_start":47,"line_end":47,"column_start":21,"column_end":58,"is_primary":true,"text":[{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":21,"highlight_end":58}],"label":"no `_mm_movemask_pi8` in `core_arch::arch::x86_64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":483,"byte_end":506,"line_start":24,"line_end":24,"column_start":17,"column_end":40,"is_primary":false,"text":[{"text":"                x86_m8x8_sse_impl!($id);","highlight_start":17,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":3527,"byte_end":3548,"line_start":144,"line_end":144,"column_start":18,"column_end":39,"is_primary":false,"text":[{"text":"    (m16x4) => { x86_m8x8_impl!(m16x4); };","highlight_start":18,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask.rs","byte_start":1138,"byte_end":1166,"line_start":47,"line_end":47,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"impl_mask_reductions!(m16x4);","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_mask_reductions!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":3408,"byte_end":5371,"line_start":141,"line_end":194,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_mask_reductions {","highlight_start":1,"highlight_end":36},{"text":"    // 64-bit wide masks","highlight_start":1,"highlight_end":25},{"text":"    (m8x8) => { x86_m8x8_impl!(m8x8); };","highlight_start":1,"highlight_end":41},{"text":"    (m16x4) => { x86_m8x8_impl!(m16x4); };","highlight_start":1,"highlight_end":43},{"text":"    (m32x2) => { x86_m8x8_impl!(m32x2); };","highlight_start":1,"highlight_end":43},{"text":"    // 128-bit wide masks","highlight_start":1,"highlight_end":26},{"text":"    (m8x16) => { x86_m8x16_impl!(m8x16); };","highlight_start":1,"highlight_end":44},{"text":"    (m16x8) => { x86_m8x16_impl!(m16x8); };","highlight_start":1,"highlight_end":44},{"text":"    (m32x4) => { x86_m32x4_impl!(m32x4); };","highlight_start":1,"highlight_end":44},{"text":"    (m64x2) => { x86_m64x2_impl!(m64x2); };","highlight_start":1,"highlight_end":44},{"text":"    (m128x1) => { x86_intr_impl!(m128x1); };","highlight_start":1,"highlight_end":45},{"text":"    // 256-bit wide masks:","highlight_start":1,"highlight_end":27},{"text":"    (m8x32) => { x86_m8x32_impl!(m8x32, m8x16); };","highlight_start":1,"highlight_end":51},{"text":"    (m16x16) => { x86_m8x32_impl!(m16x16, m16x8); };","highlight_start":1,"highlight_end":53},{"text":"    (m32x8) => { x86_m32x8_impl!(m32x8, m32x4); };","highlight_start":1,"highlight_end":51},{"text":"    (m64x4) => { x86_m64x4_impl!(m64x4, m64x2); };","highlight_start":1,"highlight_end":51},{"text":"    (m128x2) => { x86_intr_impl!(m128x2); };","highlight_start":1,"highlight_end":45},{"text":"    (msizex2) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex2, m64x2);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex2, m32x2);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (msizex4) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex4, m64x4);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex4, m32x4);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (msizex8) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex8, m64x8);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex8, m32x8);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Fallback to LLVM's default code-generation:","highlight_start":1,"highlight_end":51},{"text":"    ($id:ident) => { fallback_impl!($id); };","highlight_start":1,"highlight_end":45},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"x86_m8x8_impl!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":322,"byte_end":598,"line_start":20,"line_end":30,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! x86_m8x8_impl {","highlight_start":1,"highlight_end":29},{"text":"    ($id:ident) => {","highlight_start":1,"highlight_end":21},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(all(target_arch = \"x86_64\", target_feature = \"sse\"))] {","highlight_start":1,"highlight_end":77},{"text":"                x86_m8x8_sse_impl!($id);","highlight_start":1,"highlight_end":41},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                fallback_impl!($id);","highlight_start":1,"highlight_end":37},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"x86_m8x8_sse_impl!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs","byte_start":1343,"byte_end":2530,"line_start":38,"line_end":68,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! x86_m8x8_sse_impl {","highlight_start":1,"highlight_end":33},{"text":"    ($id:ident) => {","highlight_start":1,"highlight_end":21},{"text":"        impl All for $id {","highlight_start":1,"highlight_end":27},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            #[target_feature(enable = \"sse\")]","highlight_start":1,"highlight_end":46},{"text":"            unsafe fn all(self) -> bool {","highlight_start":1,"highlight_end":42},{"text":"                #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":44},{"text":"                use crate::arch::x86::_mm_movemask_pi8;","highlight_start":1,"highlight_end":56},{"text":"                #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":47},{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":1,"highlight_end":59},{"text":"                // _mm_movemask_pi8(a) creates an 8bit mask containing the most","highlight_start":1,"highlight_end":80},{"text":"                // significant bit of each byte of `a`. If all bits are set,","highlight_start":1,"highlight_end":77},{"text":"                // then all 8 lanes of the mask are true.","highlight_start":1,"highlight_end":58},{"text":"                _mm_movemask_pi8(crate::mem::transmute(self))","highlight_start":1,"highlight_end":62},{"text":"                    == u8::max_value() as i32","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        impl Any for $id {","highlight_start":1,"highlight_end":27},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            #[target_feature(enable = \"sse\")]","highlight_start":1,"highlight_end":46},{"text":"            unsafe fn any(self) -> bool {","highlight_start":1,"highlight_end":42},{"text":"                #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":44},{"text":"                use crate::arch::x86::_mm_movemask_pi8;","highlight_start":1,"highlight_end":56},{"text":"                #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":47},{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":1,"highlight_end":59},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                _mm_movemask_pi8(crate::mem::transmute(self)) != 0","highlight_start":1,"highlight_end":67},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"a similar name exists in the module","code":null,"level":"help","spans":[{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs","byte_start":1722,"byte_end":1738,"line_start":47,"line_end":47,"column_start":42,"column_end":58,"is_primary":true,"text":[{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":42,"highlight_end":58}],"label":null,"suggested_replacement":"_mm_movemask_epi8","suggestion_applicability":"MaybeIncorrect","expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":483,"byte_end":506,"line_start":24,"line_end":24,"column_start":17,"column_end":40,"is_primary":false,"text":[{"text":"                x86_m8x8_sse_impl!($id);","highlight_start":17,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":3527,"byte_end":3548,"line_start":144,"line_end":144,"column_start":18,"column_end":39,"is_primary":false,"text":[{"text":"    (m16x4) => { x86_m8x8_impl!(m16x4); };","highlight_start":18,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask.rs","byte_start":1138,"byte_end":1166,"line_start":47,"line_end":47,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"impl_mask_reductions!(m16x4);","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_mask_reductions!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":3408,"byte_end":5371,"line_start":141,"line_end":194,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_mask_reductions {","highlight_start":1,"highlight_end":36},{"text":"    // 64-bit wide masks","highlight_start":1,"highlight_end":25},{"text":"    (m8x8) => { x86_m8x8_impl!(m8x8); };","highlight_start":1,"highlight_end":41},{"text":"    (m16x4) => { x86_m8x8_impl!(m16x4); };","highlight_start":1,"highlight_end":43},{"text":"    (m32x2) => { x86_m8x8_impl!(m32x2); };","highlight_start":1,"highlight_end":43},{"text":"    // 128-bit wide masks","highlight_start":1,"highlight_end":26},{"text":"    (m8x16) => { x86_m8x16_impl!(m8x16); };","highlight_start":1,"highlight_end":44},{"text":"    (m16x8) => { x86_m8x16_impl!(m16x8); };","highlight_start":1,"highlight_end":44},{"text":"    (m32x4) => { x86_m32x4_impl!(m32x4); };","highlight_start":1,"highlight_end":44},{"text":"    (m64x2) => { x86_m64x2_impl!(m64x2); };","highlight_start":1,"highlight_end":44},{"text":"    (m128x1) => { x86_intr_impl!(m128x1); };","highlight_start":1,"highlight_end":45},{"text":"    // 256-bit wide masks:","highlight_start":1,"highlight_end":27},{"text":"    (m8x32) => { x86_m8x32_impl!(m8x32, m8x16); };","highlight_start":1,"highlight_end":51},{"text":"    (m16x16) => { x86_m8x32_impl!(m16x16, m16x8); };","highlight_start":1,"highlight_end":53},{"text":"    (m32x8) => { x86_m32x8_impl!(m32x8, m32x4); };","highlight_start":1,"highlight_end":51},{"text":"    (m64x4) => { x86_m64x4_impl!(m64x4, m64x2); };","highlight_start":1,"highlight_end":51},{"text":"    (m128x2) => { x86_intr_impl!(m128x2); };","highlight_start":1,"highlight_end":45},{"text":"    (msizex2) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex2, m64x2);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex2, m32x2);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (msizex4) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex4, m64x4);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex4, m32x4);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (msizex8) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex8, m64x8);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex8, m32x8);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Fallback to LLVM's default code-generation:","highlight_start":1,"highlight_end":51},{"text":"    ($id:ident) => { fallback_impl!($id); };","highlight_start":1,"highlight_end":45},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"x86_m8x8_impl!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":322,"byte_end":598,"line_start":20,"line_end":30,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! x86_m8x8_impl {","highlight_start":1,"highlight_end":29},{"text":"    ($id:ident) => {","highlight_start":1,"highlight_end":21},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(all(target_arch = \"x86_64\", target_feature = \"sse\"))] {","highlight_start":1,"highlight_end":77},{"text":"                x86_m8x8_sse_impl!($id);","highlight_start":1,"highlight_end":41},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                fallback_impl!($id);","highlight_start":1,"highlight_end":37},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"x86_m8x8_sse_impl!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs","byte_start":1343,"byte_end":2530,"line_start":38,"line_end":68,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! x86_m8x8_sse_impl {","highlight_start":1,"highlight_end":33},{"text":"    ($id:ident) => {","highlight_start":1,"highlight_end":21},{"text":"        impl All for $id {","highlight_start":1,"highlight_end":27},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            #[target_feature(enable = \"sse\")]","highlight_start":1,"highlight_end":46},{"text":"            unsafe fn all(self) -> bool {","highlight_start":1,"highlight_end":42},{"text":"                #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":44},{"text":"                use crate::arch::x86::_mm_movemask_pi8;","highlight_start":1,"highlight_end":56},{"text":"                #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":47},{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":1,"highlight_end":59},{"text":"                // _mm_movemask_pi8(a) creates an 8bit mask containing the most","highlight_start":1,"highlight_end":80},{"text":"                // significant bit of each byte of `a`. If all bits are set,","highlight_start":1,"highlight_end":77},{"text":"                // then all 8 lanes of the mask are true.","highlight_start":1,"highlight_end":58},{"text":"                _mm_movemask_pi8(crate::mem::transmute(self))","highlight_start":1,"highlight_end":62},{"text":"                    == u8::max_value() as i32","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        impl Any for $id {","highlight_start":1,"highlight_end":27},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            #[target_feature(enable = \"sse\")]","highlight_start":1,"highlight_end":46},{"text":"            unsafe fn any(self) -> bool {","highlight_start":1,"highlight_end":42},{"text":"                #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":44},{"text":"                use crate::arch::x86::_mm_movemask_pi8;","highlight_start":1,"highlight_end":56},{"text":"                #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":47},{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":1,"highlight_end":59},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                _mm_movemask_pi8(crate::mem::transmute(self)) != 0","highlight_start":1,"highlight_end":67},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m\u001b[1m: unresolved import `crate::arch::x86_64::_mm_movemask_pi8`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs:47:21\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                use crate::arch::x86_64::_mm_movemask_pi8;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: a similar name exists in the module: `_mm_movemask_epi8`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno `_mm_movemask_pi8` in `core_arch::arch::x86_64`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask.rs:47:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mimpl_mask_reductions!(m16x4);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `x86_m8x8_sse_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"unresolved import `crate::arch::x86_64::_mm_movemask_pi8`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018, paths in `use` statements are relative to the current module\nunless they begin with the name of a crate or a literal `crate::`, in which\ncase they start from the crate root. As in Rust 2015 code, the `self::` and\n`super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nIn Rust 2018 the `extern crate` declaration is not required and you can instead\njust `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs","byte_start":2391,"byte_end":2428,"line_start":62,"line_end":62,"column_start":21,"column_end":58,"is_primary":true,"text":[{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":21,"highlight_end":58}],"label":"no `_mm_movemask_pi8` in `core_arch::arch::x86_64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":483,"byte_end":506,"line_start":24,"line_end":24,"column_start":17,"column_end":40,"is_primary":false,"text":[{"text":"                x86_m8x8_sse_impl!($id);","highlight_start":17,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":3527,"byte_end":3548,"line_start":144,"line_end":144,"column_start":18,"column_end":39,"is_primary":false,"text":[{"text":"    (m16x4) => { x86_m8x8_impl!(m16x4); };","highlight_start":18,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask.rs","byte_start":1138,"byte_end":1166,"line_start":47,"line_end":47,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"impl_mask_reductions!(m16x4);","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_mask_reductions!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":3408,"byte_end":5371,"line_start":141,"line_end":194,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_mask_reductions {","highlight_start":1,"highlight_end":36},{"text":"    // 64-bit wide masks","highlight_start":1,"highlight_end":25},{"text":"    (m8x8) => { x86_m8x8_impl!(m8x8); };","highlight_start":1,"highlight_end":41},{"text":"    (m16x4) => { x86_m8x8_impl!(m16x4); };","highlight_start":1,"highlight_end":43},{"text":"    (m32x2) => { x86_m8x8_impl!(m32x2); };","highlight_start":1,"highlight_end":43},{"text":"    // 128-bit wide masks","highlight_start":1,"highlight_end":26},{"text":"    (m8x16) => { x86_m8x16_impl!(m8x16); };","highlight_start":1,"highlight_end":44},{"text":"    (m16x8) => { x86_m8x16_impl!(m16x8); };","highlight_start":1,"highlight_end":44},{"text":"    (m32x4) => { x86_m32x4_impl!(m32x4); };","highlight_start":1,"highlight_end":44},{"text":"    (m64x2) => { x86_m64x2_impl!(m64x2); };","highlight_start":1,"highlight_end":44},{"text":"    (m128x1) => { x86_intr_impl!(m128x1); };","highlight_start":1,"highlight_end":45},{"text":"    // 256-bit wide masks:","highlight_start":1,"highlight_end":27},{"text":"    (m8x32) => { x86_m8x32_impl!(m8x32, m8x16); };","highlight_start":1,"highlight_end":51},{"text":"    (m16x16) => { x86_m8x32_impl!(m16x16, m16x8); };","highlight_start":1,"highlight_end":53},{"text":"    (m32x8) => { x86_m32x8_impl!(m32x8, m32x4); };","highlight_start":1,"highlight_end":51},{"text":"    (m64x4) => { x86_m64x4_impl!(m64x4, m64x2); };","highlight_start":1,"highlight_end":51},{"text":"    (m128x2) => { x86_intr_impl!(m128x2); };","highlight_start":1,"highlight_end":45},{"text":"    (msizex2) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex2, m64x2);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex2, m32x2);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (msizex4) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex4, m64x4);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex4, m32x4);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (msizex8) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex8, m64x8);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex8, m32x8);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Fallback to LLVM's default code-generation:","highlight_start":1,"highlight_end":51},{"text":"    ($id:ident) => { fallback_impl!($id); };","highlight_start":1,"highlight_end":45},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"x86_m8x8_impl!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":322,"byte_end":598,"line_start":20,"line_end":30,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! x86_m8x8_impl {","highlight_start":1,"highlight_end":29},{"text":"    ($id:ident) => {","highlight_start":1,"highlight_end":21},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(all(target_arch = \"x86_64\", target_feature = \"sse\"))] {","highlight_start":1,"highlight_end":77},{"text":"                x86_m8x8_sse_impl!($id);","highlight_start":1,"highlight_end":41},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                fallback_impl!($id);","highlight_start":1,"highlight_end":37},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"x86_m8x8_sse_impl!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs","byte_start":1343,"byte_end":2530,"line_start":38,"line_end":68,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! x86_m8x8_sse_impl {","highlight_start":1,"highlight_end":33},{"text":"    ($id:ident) => {","highlight_start":1,"highlight_end":21},{"text":"        impl All for $id {","highlight_start":1,"highlight_end":27},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            #[target_feature(enable = \"sse\")]","highlight_start":1,"highlight_end":46},{"text":"            unsafe fn all(self) -> bool {","highlight_start":1,"highlight_end":42},{"text":"                #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":44},{"text":"                use crate::arch::x86::_mm_movemask_pi8;","highlight_start":1,"highlight_end":56},{"text":"                #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":47},{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":1,"highlight_end":59},{"text":"                // _mm_movemask_pi8(a) creates an 8bit mask containing the most","highlight_start":1,"highlight_end":80},{"text":"                // significant bit of each byte of `a`. If all bits are set,","highlight_start":1,"highlight_end":77},{"text":"                // then all 8 lanes of the mask are true.","highlight_start":1,"highlight_end":58},{"text":"                _mm_movemask_pi8(crate::mem::transmute(self))","highlight_start":1,"highlight_end":62},{"text":"                    == u8::max_value() as i32","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        impl Any for $id {","highlight_start":1,"highlight_end":27},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            #[target_feature(enable = \"sse\")]","highlight_start":1,"highlight_end":46},{"text":"            unsafe fn any(self) -> bool {","highlight_start":1,"highlight_end":42},{"text":"                #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":44},{"text":"                use crate::arch::x86::_mm_movemask_pi8;","highlight_start":1,"highlight_end":56},{"text":"                #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":47},{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":1,"highlight_end":59},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                _mm_movemask_pi8(crate::mem::transmute(self)) != 0","highlight_start":1,"highlight_end":67},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"a similar name exists in the module","code":null,"level":"help","spans":[{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs","byte_start":2412,"byte_end":2428,"line_start":62,"line_end":62,"column_start":42,"column_end":58,"is_primary":true,"text":[{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":42,"highlight_end":58}],"label":null,"suggested_replacement":"_mm_movemask_epi8","suggestion_applicability":"MaybeIncorrect","expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":483,"byte_end":506,"line_start":24,"line_end":24,"column_start":17,"column_end":40,"is_primary":false,"text":[{"text":"                x86_m8x8_sse_impl!($id);","highlight_start":17,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":3527,"byte_end":3548,"line_start":144,"line_end":144,"column_start":18,"column_end":39,"is_primary":false,"text":[{"text":"    (m16x4) => { x86_m8x8_impl!(m16x4); };","highlight_start":18,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask.rs","byte_start":1138,"byte_end":1166,"line_start":47,"line_end":47,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"impl_mask_reductions!(m16x4);","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_mask_reductions!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":3408,"byte_end":5371,"line_start":141,"line_end":194,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_mask_reductions {","highlight_start":1,"highlight_end":36},{"text":"    // 64-bit wide masks","highlight_start":1,"highlight_end":25},{"text":"    (m8x8) => { x86_m8x8_impl!(m8x8); };","highlight_start":1,"highlight_end":41},{"text":"    (m16x4) => { x86_m8x8_impl!(m16x4); };","highlight_start":1,"highlight_end":43},{"text":"    (m32x2) => { x86_m8x8_impl!(m32x2); };","highlight_start":1,"highlight_end":43},{"text":"    // 128-bit wide masks","highlight_start":1,"highlight_end":26},{"text":"    (m8x16) => { x86_m8x16_impl!(m8x16); };","highlight_start":1,"highlight_end":44},{"text":"    (m16x8) => { x86_m8x16_impl!(m16x8); };","highlight_start":1,"highlight_end":44},{"text":"    (m32x4) => { x86_m32x4_impl!(m32x4); };","highlight_start":1,"highlight_end":44},{"text":"    (m64x2) => { x86_m64x2_impl!(m64x2); };","highlight_start":1,"highlight_end":44},{"text":"    (m128x1) => { x86_intr_impl!(m128x1); };","highlight_start":1,"highlight_end":45},{"text":"    // 256-bit wide masks:","highlight_start":1,"highlight_end":27},{"text":"    (m8x32) => { x86_m8x32_impl!(m8x32, m8x16); };","highlight_start":1,"highlight_end":51},{"text":"    (m16x16) => { x86_m8x32_impl!(m16x16, m16x8); };","highlight_start":1,"highlight_end":53},{"text":"    (m32x8) => { x86_m32x8_impl!(m32x8, m32x4); };","highlight_start":1,"highlight_end":51},{"text":"    (m64x4) => { x86_m64x4_impl!(m64x4, m64x2); };","highlight_start":1,"highlight_end":51},{"text":"    (m128x2) => { x86_intr_impl!(m128x2); };","highlight_start":1,"highlight_end":45},{"text":"    (msizex2) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex2, m64x2);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex2, m32x2);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (msizex4) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex4, m64x4);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex4, m32x4);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (msizex8) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex8, m64x8);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex8, m32x8);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Fallback to LLVM's default code-generation:","highlight_start":1,"highlight_end":51},{"text":"    ($id:ident) => { fallback_impl!($id); };","highlight_start":1,"highlight_end":45},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"x86_m8x8_impl!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":322,"byte_end":598,"line_start":20,"line_end":30,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! x86_m8x8_impl {","highlight_start":1,"highlight_end":29},{"text":"    ($id:ident) => {","highlight_start":1,"highlight_end":21},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(all(target_arch = \"x86_64\", target_feature = \"sse\"))] {","highlight_start":1,"highlight_end":77},{"text":"                x86_m8x8_sse_impl!($id);","highlight_start":1,"highlight_end":41},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                fallback_impl!($id);","highlight_start":1,"highlight_end":37},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"x86_m8x8_sse_impl!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs","byte_start":1343,"byte_end":2530,"line_start":38,"line_end":68,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! x86_m8x8_sse_impl {","highlight_start":1,"highlight_end":33},{"text":"    ($id:ident) => {","highlight_start":1,"highlight_end":21},{"text":"        impl All for $id {","highlight_start":1,"highlight_end":27},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            #[target_feature(enable = \"sse\")]","highlight_start":1,"highlight_end":46},{"text":"            unsafe fn all(self) -> bool {","highlight_start":1,"highlight_end":42},{"text":"                #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":44},{"text":"                use crate::arch::x86::_mm_movemask_pi8;","highlight_start":1,"highlight_end":56},{"text":"                #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":47},{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":1,"highlight_end":59},{"text":"                // _mm_movemask_pi8(a) creates an 8bit mask containing the most","highlight_start":1,"highlight_end":80},{"text":"                // significant bit of each byte of `a`. If all bits are set,","highlight_start":1,"highlight_end":77},{"text":"                // then all 8 lanes of the mask are true.","highlight_start":1,"highlight_end":58},{"text":"                _mm_movemask_pi8(crate::mem::transmute(self))","highlight_start":1,"highlight_end":62},{"text":"                    == u8::max_value() as i32","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        impl Any for $id {","highlight_start":1,"highlight_end":27},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            #[target_feature(enable = \"sse\")]","highlight_start":1,"highlight_end":46},{"text":"            unsafe fn any(self) -> bool {","highlight_start":1,"highlight_end":42},{"text":"                #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":44},{"text":"                use crate::arch::x86::_mm_movemask_pi8;","highlight_start":1,"highlight_end":56},{"text":"                #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":47},{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":1,"highlight_end":59},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                _mm_movemask_pi8(crate::mem::transmute(self)) != 0","highlight_start":1,"highlight_end":67},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m\u001b[1m: unresolved import `crate::arch::x86_64::_mm_movemask_pi8`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs:62:21\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m62\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                use crate::arch::x86_64::_mm_movemask_pi8;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: a similar name exists in the module: `_mm_movemask_epi8`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno `_mm_movemask_pi8` in `core_arch::arch::x86_64`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask.rs:47:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mimpl_mask_reductions!(m16x4);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `x86_m8x8_sse_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"unresolved import `crate::arch::x86_64::_mm_movemask_pi8`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018, paths in `use` statements are relative to the current module\nunless they begin with the name of a crate or a literal `crate::`, in which\ncase they start from the crate root. As in Rust 2015 code, the `self::` and\n`super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nIn Rust 2018 the `extern crate` declaration is not required and you can instead\njust `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs","byte_start":1701,"byte_end":1738,"line_start":47,"line_end":47,"column_start":21,"column_end":58,"is_primary":true,"text":[{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":21,"highlight_end":58}],"label":"no `_mm_movemask_pi8` in `core_arch::arch::x86_64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":483,"byte_end":506,"line_start":24,"line_end":24,"column_start":17,"column_end":40,"is_primary":false,"text":[{"text":"                x86_m8x8_sse_impl!($id);","highlight_start":17,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":3570,"byte_end":3591,"line_start":145,"line_end":145,"column_start":18,"column_end":39,"is_primary":false,"text":[{"text":"    (m32x2) => { x86_m8x8_impl!(m32x2); };","highlight_start":18,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask.rs","byte_start":1261,"byte_end":1289,"line_start":52,"line_end":52,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"impl_mask_reductions!(m32x2);","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_mask_reductions!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":3408,"byte_end":5371,"line_start":141,"line_end":194,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_mask_reductions {","highlight_start":1,"highlight_end":36},{"text":"    // 64-bit wide masks","highlight_start":1,"highlight_end":25},{"text":"    (m8x8) => { x86_m8x8_impl!(m8x8); };","highlight_start":1,"highlight_end":41},{"text":"    (m16x4) => { x86_m8x8_impl!(m16x4); };","highlight_start":1,"highlight_end":43},{"text":"    (m32x2) => { x86_m8x8_impl!(m32x2); };","highlight_start":1,"highlight_end":43},{"text":"    // 128-bit wide masks","highlight_start":1,"highlight_end":26},{"text":"    (m8x16) => { x86_m8x16_impl!(m8x16); };","highlight_start":1,"highlight_end":44},{"text":"    (m16x8) => { x86_m8x16_impl!(m16x8); };","highlight_start":1,"highlight_end":44},{"text":"    (m32x4) => { x86_m32x4_impl!(m32x4); };","highlight_start":1,"highlight_end":44},{"text":"    (m64x2) => { x86_m64x2_impl!(m64x2); };","highlight_start":1,"highlight_end":44},{"text":"    (m128x1) => { x86_intr_impl!(m128x1); };","highlight_start":1,"highlight_end":45},{"text":"    // 256-bit wide masks:","highlight_start":1,"highlight_end":27},{"text":"    (m8x32) => { x86_m8x32_impl!(m8x32, m8x16); };","highlight_start":1,"highlight_end":51},{"text":"    (m16x16) => { x86_m8x32_impl!(m16x16, m16x8); };","highlight_start":1,"highlight_end":53},{"text":"    (m32x8) => { x86_m32x8_impl!(m32x8, m32x4); };","highlight_start":1,"highlight_end":51},{"text":"    (m64x4) => { x86_m64x4_impl!(m64x4, m64x2); };","highlight_start":1,"highlight_end":51},{"text":"    (m128x2) => { x86_intr_impl!(m128x2); };","highlight_start":1,"highlight_end":45},{"text":"    (msizex2) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex2, m64x2);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex2, m32x2);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (msizex4) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex4, m64x4);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex4, m32x4);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (msizex8) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex8, m64x8);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex8, m32x8);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Fallback to LLVM's default code-generation:","highlight_start":1,"highlight_end":51},{"text":"    ($id:ident) => { fallback_impl!($id); };","highlight_start":1,"highlight_end":45},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"x86_m8x8_impl!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":322,"byte_end":598,"line_start":20,"line_end":30,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! x86_m8x8_impl {","highlight_start":1,"highlight_end":29},{"text":"    ($id:ident) => {","highlight_start":1,"highlight_end":21},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(all(target_arch = \"x86_64\", target_feature = \"sse\"))] {","highlight_start":1,"highlight_end":77},{"text":"                x86_m8x8_sse_impl!($id);","highlight_start":1,"highlight_end":41},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                fallback_impl!($id);","highlight_start":1,"highlight_end":37},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"x86_m8x8_sse_impl!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs","byte_start":1343,"byte_end":2530,"line_start":38,"line_end":68,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! x86_m8x8_sse_impl {","highlight_start":1,"highlight_end":33},{"text":"    ($id:ident) => {","highlight_start":1,"highlight_end":21},{"text":"        impl All for $id {","highlight_start":1,"highlight_end":27},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            #[target_feature(enable = \"sse\")]","highlight_start":1,"highlight_end":46},{"text":"            unsafe fn all(self) -> bool {","highlight_start":1,"highlight_end":42},{"text":"                #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":44},{"text":"                use crate::arch::x86::_mm_movemask_pi8;","highlight_start":1,"highlight_end":56},{"text":"                #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":47},{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":1,"highlight_end":59},{"text":"                // _mm_movemask_pi8(a) creates an 8bit mask containing the most","highlight_start":1,"highlight_end":80},{"text":"                // significant bit of each byte of `a`. If all bits are set,","highlight_start":1,"highlight_end":77},{"text":"                // then all 8 lanes of the mask are true.","highlight_start":1,"highlight_end":58},{"text":"                _mm_movemask_pi8(crate::mem::transmute(self))","highlight_start":1,"highlight_end":62},{"text":"                    == u8::max_value() as i32","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        impl Any for $id {","highlight_start":1,"highlight_end":27},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            #[target_feature(enable = \"sse\")]","highlight_start":1,"highlight_end":46},{"text":"            unsafe fn any(self) -> bool {","highlight_start":1,"highlight_end":42},{"text":"                #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":44},{"text":"                use crate::arch::x86::_mm_movemask_pi8;","highlight_start":1,"highlight_end":56},{"text":"                #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":47},{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":1,"highlight_end":59},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                _mm_movemask_pi8(crate::mem::transmute(self)) != 0","highlight_start":1,"highlight_end":67},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"a similar name exists in the module","code":null,"level":"help","spans":[{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs","byte_start":1722,"byte_end":1738,"line_start":47,"line_end":47,"column_start":42,"column_end":58,"is_primary":true,"text":[{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":42,"highlight_end":58}],"label":null,"suggested_replacement":"_mm_movemask_epi8","suggestion_applicability":"MaybeIncorrect","expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":483,"byte_end":506,"line_start":24,"line_end":24,"column_start":17,"column_end":40,"is_primary":false,"text":[{"text":"                x86_m8x8_sse_impl!($id);","highlight_start":17,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":3570,"byte_end":3591,"line_start":145,"line_end":145,"column_start":18,"column_end":39,"is_primary":false,"text":[{"text":"    (m32x2) => { x86_m8x8_impl!(m32x2); };","highlight_start":18,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask.rs","byte_start":1261,"byte_end":1289,"line_start":52,"line_end":52,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"impl_mask_reductions!(m32x2);","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_mask_reductions!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":3408,"byte_end":5371,"line_start":141,"line_end":194,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_mask_reductions {","highlight_start":1,"highlight_end":36},{"text":"    // 64-bit wide masks","highlight_start":1,"highlight_end":25},{"text":"    (m8x8) => { x86_m8x8_impl!(m8x8); };","highlight_start":1,"highlight_end":41},{"text":"    (m16x4) => { x86_m8x8_impl!(m16x4); };","highlight_start":1,"highlight_end":43},{"text":"    (m32x2) => { x86_m8x8_impl!(m32x2); };","highlight_start":1,"highlight_end":43},{"text":"    // 128-bit wide masks","highlight_start":1,"highlight_end":26},{"text":"    (m8x16) => { x86_m8x16_impl!(m8x16); };","highlight_start":1,"highlight_end":44},{"text":"    (m16x8) => { x86_m8x16_impl!(m16x8); };","highlight_start":1,"highlight_end":44},{"text":"    (m32x4) => { x86_m32x4_impl!(m32x4); };","highlight_start":1,"highlight_end":44},{"text":"    (m64x2) => { x86_m64x2_impl!(m64x2); };","highlight_start":1,"highlight_end":44},{"text":"    (m128x1) => { x86_intr_impl!(m128x1); };","highlight_start":1,"highlight_end":45},{"text":"    // 256-bit wide masks:","highlight_start":1,"highlight_end":27},{"text":"    (m8x32) => { x86_m8x32_impl!(m8x32, m8x16); };","highlight_start":1,"highlight_end":51},{"text":"    (m16x16) => { x86_m8x32_impl!(m16x16, m16x8); };","highlight_start":1,"highlight_end":53},{"text":"    (m32x8) => { x86_m32x8_impl!(m32x8, m32x4); };","highlight_start":1,"highlight_end":51},{"text":"    (m64x4) => { x86_m64x4_impl!(m64x4, m64x2); };","highlight_start":1,"highlight_end":51},{"text":"    (m128x2) => { x86_intr_impl!(m128x2); };","highlight_start":1,"highlight_end":45},{"text":"    (msizex2) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex2, m64x2);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex2, m32x2);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (msizex4) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex4, m64x4);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex4, m32x4);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (msizex8) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex8, m64x8);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex8, m32x8);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Fallback to LLVM's default code-generation:","highlight_start":1,"highlight_end":51},{"text":"    ($id:ident) => { fallback_impl!($id); };","highlight_start":1,"highlight_end":45},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"x86_m8x8_impl!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":322,"byte_end":598,"line_start":20,"line_end":30,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! x86_m8x8_impl {","highlight_start":1,"highlight_end":29},{"text":"    ($id:ident) => {","highlight_start":1,"highlight_end":21},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(all(target_arch = \"x86_64\", target_feature = \"sse\"))] {","highlight_start":1,"highlight_end":77},{"text":"                x86_m8x8_sse_impl!($id);","highlight_start":1,"highlight_end":41},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                fallback_impl!($id);","highlight_start":1,"highlight_end":37},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"x86_m8x8_sse_impl!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs","byte_start":1343,"byte_end":2530,"line_start":38,"line_end":68,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! x86_m8x8_sse_impl {","highlight_start":1,"highlight_end":33},{"text":"    ($id:ident) => {","highlight_start":1,"highlight_end":21},{"text":"        impl All for $id {","highlight_start":1,"highlight_end":27},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            #[target_feature(enable = \"sse\")]","highlight_start":1,"highlight_end":46},{"text":"            unsafe fn all(self) -> bool {","highlight_start":1,"highlight_end":42},{"text":"                #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":44},{"text":"                use crate::arch::x86::_mm_movemask_pi8;","highlight_start":1,"highlight_end":56},{"text":"                #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":47},{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":1,"highlight_end":59},{"text":"                // _mm_movemask_pi8(a) creates an 8bit mask containing the most","highlight_start":1,"highlight_end":80},{"text":"                // significant bit of each byte of `a`. If all bits are set,","highlight_start":1,"highlight_end":77},{"text":"                // then all 8 lanes of the mask are true.","highlight_start":1,"highlight_end":58},{"text":"                _mm_movemask_pi8(crate::mem::transmute(self))","highlight_start":1,"highlight_end":62},{"text":"                    == u8::max_value() as i32","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        impl Any for $id {","highlight_start":1,"highlight_end":27},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            #[target_feature(enable = \"sse\")]","highlight_start":1,"highlight_end":46},{"text":"            unsafe fn any(self) -> bool {","highlight_start":1,"highlight_end":42},{"text":"                #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":44},{"text":"                use crate::arch::x86::_mm_movemask_pi8;","highlight_start":1,"highlight_end":56},{"text":"                #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":47},{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":1,"highlight_end":59},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                _mm_movemask_pi8(crate::mem::transmute(self)) != 0","highlight_start":1,"highlight_end":67},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m\u001b[1m: unresolved import `crate::arch::x86_64::_mm_movemask_pi8`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs:47:21\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                use crate::arch::x86_64::_mm_movemask_pi8;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: a similar name exists in the module: `_mm_movemask_epi8`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno `_mm_movemask_pi8` in `core_arch::arch::x86_64`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask.rs:52:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m52\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mimpl_mask_reductions!(m32x2);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `x86_m8x8_sse_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"unresolved import `crate::arch::x86_64::_mm_movemask_pi8`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018, paths in `use` statements are relative to the current module\nunless they begin with the name of a crate or a literal `crate::`, in which\ncase they start from the crate root. As in Rust 2015 code, the `self::` and\n`super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nIn Rust 2018 the `extern crate` declaration is not required and you can instead\njust `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs","byte_start":2391,"byte_end":2428,"line_start":62,"line_end":62,"column_start":21,"column_end":58,"is_primary":true,"text":[{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":21,"highlight_end":58}],"label":"no `_mm_movemask_pi8` in `core_arch::arch::x86_64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":483,"byte_end":506,"line_start":24,"line_end":24,"column_start":17,"column_end":40,"is_primary":false,"text":[{"text":"                x86_m8x8_sse_impl!($id);","highlight_start":17,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":3570,"byte_end":3591,"line_start":145,"line_end":145,"column_start":18,"column_end":39,"is_primary":false,"text":[{"text":"    (m32x2) => { x86_m8x8_impl!(m32x2); };","highlight_start":18,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask.rs","byte_start":1261,"byte_end":1289,"line_start":52,"line_end":52,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"impl_mask_reductions!(m32x2);","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_mask_reductions!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":3408,"byte_end":5371,"line_start":141,"line_end":194,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_mask_reductions {","highlight_start":1,"highlight_end":36},{"text":"    // 64-bit wide masks","highlight_start":1,"highlight_end":25},{"text":"    (m8x8) => { x86_m8x8_impl!(m8x8); };","highlight_start":1,"highlight_end":41},{"text":"    (m16x4) => { x86_m8x8_impl!(m16x4); };","highlight_start":1,"highlight_end":43},{"text":"    (m32x2) => { x86_m8x8_impl!(m32x2); };","highlight_start":1,"highlight_end":43},{"text":"    // 128-bit wide masks","highlight_start":1,"highlight_end":26},{"text":"    (m8x16) => { x86_m8x16_impl!(m8x16); };","highlight_start":1,"highlight_end":44},{"text":"    (m16x8) => { x86_m8x16_impl!(m16x8); };","highlight_start":1,"highlight_end":44},{"text":"    (m32x4) => { x86_m32x4_impl!(m32x4); };","highlight_start":1,"highlight_end":44},{"text":"    (m64x2) => { x86_m64x2_impl!(m64x2); };","highlight_start":1,"highlight_end":44},{"text":"    (m128x1) => { x86_intr_impl!(m128x1); };","highlight_start":1,"highlight_end":45},{"text":"    // 256-bit wide masks:","highlight_start":1,"highlight_end":27},{"text":"    (m8x32) => { x86_m8x32_impl!(m8x32, m8x16); };","highlight_start":1,"highlight_end":51},{"text":"    (m16x16) => { x86_m8x32_impl!(m16x16, m16x8); };","highlight_start":1,"highlight_end":53},{"text":"    (m32x8) => { x86_m32x8_impl!(m32x8, m32x4); };","highlight_start":1,"highlight_end":51},{"text":"    (m64x4) => { x86_m64x4_impl!(m64x4, m64x2); };","highlight_start":1,"highlight_end":51},{"text":"    (m128x2) => { x86_intr_impl!(m128x2); };","highlight_start":1,"highlight_end":45},{"text":"    (msizex2) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex2, m64x2);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex2, m32x2);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (msizex4) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex4, m64x4);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex4, m32x4);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (msizex8) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex8, m64x8);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex8, m32x8);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Fallback to LLVM's default code-generation:","highlight_start":1,"highlight_end":51},{"text":"    ($id:ident) => { fallback_impl!($id); };","highlight_start":1,"highlight_end":45},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"x86_m8x8_impl!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":322,"byte_end":598,"line_start":20,"line_end":30,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! x86_m8x8_impl {","highlight_start":1,"highlight_end":29},{"text":"    ($id:ident) => {","highlight_start":1,"highlight_end":21},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(all(target_arch = \"x86_64\", target_feature = \"sse\"))] {","highlight_start":1,"highlight_end":77},{"text":"                x86_m8x8_sse_impl!($id);","highlight_start":1,"highlight_end":41},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                fallback_impl!($id);","highlight_start":1,"highlight_end":37},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"x86_m8x8_sse_impl!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs","byte_start":1343,"byte_end":2530,"line_start":38,"line_end":68,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! x86_m8x8_sse_impl {","highlight_start":1,"highlight_end":33},{"text":"    ($id:ident) => {","highlight_start":1,"highlight_end":21},{"text":"        impl All for $id {","highlight_start":1,"highlight_end":27},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            #[target_feature(enable = \"sse\")]","highlight_start":1,"highlight_end":46},{"text":"            unsafe fn all(self) -> bool {","highlight_start":1,"highlight_end":42},{"text":"                #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":44},{"text":"                use crate::arch::x86::_mm_movemask_pi8;","highlight_start":1,"highlight_end":56},{"text":"                #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":47},{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":1,"highlight_end":59},{"text":"                // _mm_movemask_pi8(a) creates an 8bit mask containing the most","highlight_start":1,"highlight_end":80},{"text":"                // significant bit of each byte of `a`. If all bits are set,","highlight_start":1,"highlight_end":77},{"text":"                // then all 8 lanes of the mask are true.","highlight_start":1,"highlight_end":58},{"text":"                _mm_movemask_pi8(crate::mem::transmute(self))","highlight_start":1,"highlight_end":62},{"text":"                    == u8::max_value() as i32","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        impl Any for $id {","highlight_start":1,"highlight_end":27},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            #[target_feature(enable = \"sse\")]","highlight_start":1,"highlight_end":46},{"text":"            unsafe fn any(self) -> bool {","highlight_start":1,"highlight_end":42},{"text":"                #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":44},{"text":"                use crate::arch::x86::_mm_movemask_pi8;","highlight_start":1,"highlight_end":56},{"text":"                #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":47},{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":1,"highlight_end":59},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                _mm_movemask_pi8(crate::mem::transmute(self)) != 0","highlight_start":1,"highlight_end":67},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"a similar name exists in the module","code":null,"level":"help","spans":[{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs","byte_start":2412,"byte_end":2428,"line_start":62,"line_end":62,"column_start":42,"column_end":58,"is_primary":true,"text":[{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":42,"highlight_end":58}],"label":null,"suggested_replacement":"_mm_movemask_epi8","suggestion_applicability":"MaybeIncorrect","expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":483,"byte_end":506,"line_start":24,"line_end":24,"column_start":17,"column_end":40,"is_primary":false,"text":[{"text":"                x86_m8x8_sse_impl!($id);","highlight_start":17,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":3570,"byte_end":3591,"line_start":145,"line_end":145,"column_start":18,"column_end":39,"is_primary":false,"text":[{"text":"    (m32x2) => { x86_m8x8_impl!(m32x2); };","highlight_start":18,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask.rs","byte_start":1261,"byte_end":1289,"line_start":52,"line_end":52,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"impl_mask_reductions!(m32x2);","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_mask_reductions!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":3408,"byte_end":5371,"line_start":141,"line_end":194,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_mask_reductions {","highlight_start":1,"highlight_end":36},{"text":"    // 64-bit wide masks","highlight_start":1,"highlight_end":25},{"text":"    (m8x8) => { x86_m8x8_impl!(m8x8); };","highlight_start":1,"highlight_end":41},{"text":"    (m16x4) => { x86_m8x8_impl!(m16x4); };","highlight_start":1,"highlight_end":43},{"text":"    (m32x2) => { x86_m8x8_impl!(m32x2); };","highlight_start":1,"highlight_end":43},{"text":"    // 128-bit wide masks","highlight_start":1,"highlight_end":26},{"text":"    (m8x16) => { x86_m8x16_impl!(m8x16); };","highlight_start":1,"highlight_end":44},{"text":"    (m16x8) => { x86_m8x16_impl!(m16x8); };","highlight_start":1,"highlight_end":44},{"text":"    (m32x4) => { x86_m32x4_impl!(m32x4); };","highlight_start":1,"highlight_end":44},{"text":"    (m64x2) => { x86_m64x2_impl!(m64x2); };","highlight_start":1,"highlight_end":44},{"text":"    (m128x1) => { x86_intr_impl!(m128x1); };","highlight_start":1,"highlight_end":45},{"text":"    // 256-bit wide masks:","highlight_start":1,"highlight_end":27},{"text":"    (m8x32) => { x86_m8x32_impl!(m8x32, m8x16); };","highlight_start":1,"highlight_end":51},{"text":"    (m16x16) => { x86_m8x32_impl!(m16x16, m16x8); };","highlight_start":1,"highlight_end":53},{"text":"    (m32x8) => { x86_m32x8_impl!(m32x8, m32x4); };","highlight_start":1,"highlight_end":51},{"text":"    (m64x4) => { x86_m64x4_impl!(m64x4, m64x2); };","highlight_start":1,"highlight_end":51},{"text":"    (m128x2) => { x86_intr_impl!(m128x2); };","highlight_start":1,"highlight_end":45},{"text":"    (msizex2) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex2, m64x2);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex2, m32x2);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (msizex4) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex4, m64x4);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex4, m32x4);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (msizex8) => {","highlight_start":1,"highlight_end":19},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(target_pointer_width = \"64\")] {","highlight_start":1,"highlight_end":53},{"text":"                fallback_to_other_impl!(msizex8, m64x8);","highlight_start":1,"highlight_end":57},{"text":"            } else if #[cfg(target_pointer_width = \"32\")] {","highlight_start":1,"highlight_end":60},{"text":"                fallback_to_other_impl!(msizex8, m32x8);","highlight_start":1,"highlight_end":57},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                compile_error!(\"unsupported target_pointer_width\");","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Fallback to LLVM's default code-generation:","highlight_start":1,"highlight_end":51},{"text":"    ($id:ident) => { fallback_impl!($id); };","highlight_start":1,"highlight_end":45},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"x86_m8x8_impl!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86.rs","byte_start":322,"byte_end":598,"line_start":20,"line_end":30,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! x86_m8x8_impl {","highlight_start":1,"highlight_end":29},{"text":"    ($id:ident) => {","highlight_start":1,"highlight_end":21},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(all(target_arch = \"x86_64\", target_feature = \"sse\"))] {","highlight_start":1,"highlight_end":77},{"text":"                x86_m8x8_sse_impl!($id);","highlight_start":1,"highlight_end":41},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                fallback_impl!($id);","highlight_start":1,"highlight_end":37},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"x86_m8x8_sse_impl!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs","byte_start":1343,"byte_end":2530,"line_start":38,"line_end":68,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! x86_m8x8_sse_impl {","highlight_start":1,"highlight_end":33},{"text":"    ($id:ident) => {","highlight_start":1,"highlight_end":21},{"text":"        impl All for $id {","highlight_start":1,"highlight_end":27},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            #[target_feature(enable = \"sse\")]","highlight_start":1,"highlight_end":46},{"text":"            unsafe fn all(self) -> bool {","highlight_start":1,"highlight_end":42},{"text":"                #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":44},{"text":"                use crate::arch::x86::_mm_movemask_pi8;","highlight_start":1,"highlight_end":56},{"text":"                #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":47},{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":1,"highlight_end":59},{"text":"                // _mm_movemask_pi8(a) creates an 8bit mask containing the most","highlight_start":1,"highlight_end":80},{"text":"                // significant bit of each byte of `a`. If all bits are set,","highlight_start":1,"highlight_end":77},{"text":"                // then all 8 lanes of the mask are true.","highlight_start":1,"highlight_end":58},{"text":"                _mm_movemask_pi8(crate::mem::transmute(self))","highlight_start":1,"highlight_end":62},{"text":"                    == u8::max_value() as i32","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        impl Any for $id {","highlight_start":1,"highlight_end":27},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            #[target_feature(enable = \"sse\")]","highlight_start":1,"highlight_end":46},{"text":"            unsafe fn any(self) -> bool {","highlight_start":1,"highlight_end":42},{"text":"                #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":44},{"text":"                use crate::arch::x86::_mm_movemask_pi8;","highlight_start":1,"highlight_end":56},{"text":"                #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":47},{"text":"                use crate::arch::x86_64::_mm_movemask_pi8;","highlight_start":1,"highlight_end":59},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                _mm_movemask_pi8(crate::mem::transmute(self)) != 0","highlight_start":1,"highlight_end":67},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m\u001b[1m: unresolved import `crate::arch::x86_64::_mm_movemask_pi8`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask/x86/sse.rs:62:21\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m62\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                use crate::arch::x86_64::_mm_movemask_pi8;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: a similar name exists in the module: `_mm_movemask_epi8`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno `_mm_movemask_pi8` in `core_arch::arch::x86_64`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/reductions/mask.rs:52:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m52\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mimpl_mask_reductions!(m32x2);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `x86_m8x8_sse_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"unresolved import `crate::arch::x86_64::_mm_shuffle_pi8`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018, paths in `use` statements are relative to the current module\nunless they begin with the name of a crate or a literal `crate::`, in which\ncase they start from the crate root. As in Rust 2015 code, the `self::` and\n`super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nIn Rust 2018 the `extern crate` declaration is not required and you can instead\njust `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/shuffle1_dyn.rs","byte_start":1266,"byte_end":1302,"line_start":40,"line_end":40,"column_start":29,"column_end":65,"is_primary":true,"text":[{"text":"                        use crate::arch::x86_64::_mm_shuffle_pi8;","highlight_start":29,"highlight_end":65}],"label":"no `_mm_shuffle_pi8` in `core_arch::arch::x86_64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/shuffle1_dyn.rs","byte_start":11980,"byte_end":12004,"line_start":297,"line_end":297,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"impl_shuffle1_dyn!(u8x8);","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_shuffle1_dyn!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/shuffle1_dyn.rs","byte_start":680,"byte_end":11926,"line_start":28,"line_end":293,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_shuffle1_dyn {","highlight_start":1,"highlight_end":33},{"text":"    (u8x8) => {","highlight_start":1,"highlight_end":16},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(all(any(target_arch = \"x86\", target_arch = \"x86_64\"),","highlight_start":1,"highlight_end":75},{"text":"                         target_feature = \"ssse3\"))] {","highlight_start":1,"highlight_end":55},{"text":"                impl Shuffle1Dyn for u8x8 {","highlight_start":1,"highlight_end":44},{"text":"                    type Indices = Self;","highlight_start":1,"highlight_end":41},{"text":"                    #[inline]","highlight_start":1,"highlight_end":30},{"text":"                    fn shuffle1_dyn(self, indices: Self::Indices) -> Self {","highlight_start":1,"highlight_end":76},{"text":"                        #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":52},{"text":"                        use crate::arch::x86::_mm_shuffle_pi8;","highlight_start":1,"highlight_end":63},{"text":"                        #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":55},{"text":"                        use crate::arch::x86_64::_mm_shuffle_pi8;","highlight_start":1,"highlight_end":66},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        unsafe {","highlight_start":1,"highlight_end":33},{"text":"                            crate::mem::transmute(","highlight_start":1,"highlight_end":51},{"text":"                                _mm_shuffle_pi8(","highlight_start":1,"highlight_end":49},{"text":"                                    crate::mem::transmute(self.0),","highlight_start":1,"highlight_end":67},{"text":"                                    crate::mem::transmute(indices.0)","highlight_start":1,"highlight_end":69},{"text":"                                )","highlight_start":1,"highlight_end":34},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            } else if #[cfg(all(","highlight_start":1,"highlight_end":33},{"text":"                any(","highlight_start":1,"highlight_end":21},{"text":"                    all(target_aarch = \"aarch64\", target_feature = \"neon\"),","highlight_start":1,"highlight_end":76},{"text":"                    all(target_aarch = \"arm\", target_feature = \"v7\",","highlight_start":1,"highlight_end":69},{"text":"                        target_feature = \"neon\")","highlight_start":1,"highlight_end":49},{"text":"                ),","highlight_start":1,"highlight_end":19},{"text":"                any(feature = \"core_arch\", libcore_neon)","highlight_start":1,"highlight_end":57},{"text":"            )","highlight_start":1,"highlight_end":14},{"text":"            )] {","highlight_start":1,"highlight_end":17},{"text":"                impl Shuffle1Dyn for u8x8 {","highlight_start":1,"highlight_end":44},{"text":"                    type Indices = Self;","highlight_start":1,"highlight_end":41},{"text":"                    #[inline]","highlight_start":1,"highlight_end":30},{"text":"                    fn shuffle1_dyn(self, indices: Self::Indices) -> Self {","highlight_start":1,"highlight_end":76},{"text":"                        #[cfg(targt_arch = \"aarch64\")]","highlight_start":1,"highlight_end":55},{"text":"                        use crate::arch::aarch64::vtbl1_u8;","highlight_start":1,"highlight_end":60},{"text":"                        #[cfg(targt_arch = \"arm\")]","highlight_start":1,"highlight_end":51},{"text":"                        use crate::arch::arm::vtbl1_u8;","highlight_start":1,"highlight_end":56},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // This is safe because the binary is compiled with","highlight_start":1,"highlight_end":76},{"text":"                        // neon enabled at compile-time and can therefore only","highlight_start":1,"highlight_end":79},{"text":"                        // run on CPUs that have it enabled.","highlight_start":1,"highlight_end":61},{"text":"                        unsafe {","highlight_start":1,"highlight_end":33},{"text":"                            Simd(mem::transmute(","highlight_start":1,"highlight_end":49},{"text":"                                vtbl1_u8(mem::transmute(self.0),","highlight_start":1,"highlight_end":65},{"text":"                                        crate::mem::transmute(indices.0))","highlight_start":1,"highlight_end":74},{"text":"                            ))","highlight_start":1,"highlight_end":31},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                impl_fallback!(u8x8);","highlight_start":1,"highlight_end":38},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (u8x16) => {","highlight_start":1,"highlight_end":17},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(all(any(target_arch = \"x86\", target_arch = \"x86_64\"),","highlight_start":1,"highlight_end":75},{"text":"                         target_feature = \"ssse3\"))] {","highlight_start":1,"highlight_end":55},{"text":"                impl Shuffle1Dyn for u8x16 {","highlight_start":1,"highlight_end":45},{"text":"                    type Indices = Self;","highlight_start":1,"highlight_end":41},{"text":"                    #[inline]","highlight_start":1,"highlight_end":30},{"text":"                    fn shuffle1_dyn(self, indices: Self::Indices) -> Self {","highlight_start":1,"highlight_end":76},{"text":"                        #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":52},{"text":"                        use crate::arch::x86::_mm_shuffle_epi8;","highlight_start":1,"highlight_end":64},{"text":"                        #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":55},{"text":"                        use crate::arch::x86_64::_mm_shuffle_epi8;","highlight_start":1,"highlight_end":67},{"text":"                        // This is safe because the binary is compiled with","highlight_start":1,"highlight_end":76},{"text":"                        // ssse3 enabled at compile-time and can therefore only","highlight_start":1,"highlight_end":80},{"text":"                        // run on CPUs that have it enabled.","highlight_start":1,"highlight_end":61},{"text":"                        unsafe {","highlight_start":1,"highlight_end":33},{"text":"                            Simd(mem::transmute(","highlight_start":1,"highlight_end":49},{"text":"                                _mm_shuffle_epi8(mem::transmute(self.0),","highlight_start":1,"highlight_end":73},{"text":"                                                crate::mem::transmute(indices))","highlight_start":1,"highlight_end":80},{"text":"                            ))","highlight_start":1,"highlight_end":31},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            } else if #[cfg(all(target_aarch = \"aarch64\", target_feature = \"neon\",","highlight_start":1,"highlight_end":83},{"text":"                                any(feature = \"core_arch\", libcore_neon)))] {","highlight_start":1,"highlight_end":78},{"text":"                impl Shuffle1Dyn for u8x16 {","highlight_start":1,"highlight_end":45},{"text":"                    type Indices = Self;","highlight_start":1,"highlight_end":41},{"text":"                    #[inline]","highlight_start":1,"highlight_end":30},{"text":"                    fn shuffle1_dyn(self, indices: Self::Indices) -> Self {","highlight_start":1,"highlight_end":76},{"text":"                        use crate::arch::aarch64::vqtbl1q_u8;","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // This is safe because the binary is compiled with","highlight_start":1,"highlight_end":76},{"text":"                        // neon enabled at compile-time and can therefore only","highlight_start":1,"highlight_end":79},{"text":"                        // run on CPUs that have it enabled.","highlight_start":1,"highlight_end":61},{"text":"                        unsafe {","highlight_start":1,"highlight_end":33},{"text":"                            Simd(mem::transmute(","highlight_start":1,"highlight_end":49},{"text":"                                vqtbl1q_u8(mem::transmute(self.0),","highlight_start":1,"highlight_end":67},{"text":"                                          crate::mem::transmute(indices.0))","highlight_start":1,"highlight_end":76},{"text":"                            ))","highlight_start":1,"highlight_end":31},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            } else if #[cfg(all(target_aarch = \"arm\", target_feature = \"v7\",","highlight_start":1,"highlight_end":77},{"text":"                                target_feature = \"neon\",","highlight_start":1,"highlight_end":57},{"text":"                                any(feature = \"core_arch\", libcore_neon)))] {","highlight_start":1,"highlight_end":78},{"text":"                impl Shuffle1Dyn for u8x16 {","highlight_start":1,"highlight_end":45},{"text":"                    type Indices = Self;","highlight_start":1,"highlight_end":41},{"text":"                    #[inline]","highlight_start":1,"highlight_end":30},{"text":"                    fn shuffle1_dyn(self, indices: Self::Indices) -> Self {","highlight_start":1,"highlight_end":76},{"text":"                        use crate::arch::arm::vtbl2_u8;","highlight_start":1,"highlight_end":56},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // This is safe because the binary is compiled with","highlight_start":1,"highlight_end":76},{"text":"                        // neon enabled at compile-time and can therefore only","highlight_start":1,"highlight_end":79},{"text":"                        // run on CPUs that have it enabled.","highlight_start":1,"highlight_end":61},{"text":"                        unsafe {","highlight_start":1,"highlight_end":33},{"text":"                            union U {","highlight_start":1,"highlight_end":38},{"text":"                                j: u8x16,","highlight_start":1,"highlight_end":42},{"text":"                                s: (u8x8, u8x8),","highlight_start":1,"highlight_end":49},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let (i0, i1) = U { j: y }.s;","highlight_start":1,"highlight_end":57},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let r0 = vtbl2_u8(","highlight_start":1,"highlight_end":47},{"text":"                                mem::transmute(x),","highlight_start":1,"highlight_end":51},{"text":"                                crate::mem::transmute(i0)","highlight_start":1,"highlight_end":58},{"text":"                            );","highlight_start":1,"highlight_end":31},{"text":"                            let r1 = vtbl2_u8(","highlight_start":1,"highlight_end":47},{"text":"                                mem::transmute(x),","highlight_start":1,"highlight_end":51},{"text":"                                crate::mem::transmute(i1)","highlight_start":1,"highlight_end":58},{"text":"                            );","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let r = U { s: (r0, r1) }.j;","highlight_start":1,"highlight_end":57},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            Simd(mem::transmute(r))","highlight_start":1,"highlight_end":52},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                impl_fallback!(u8x16);","highlight_start":1,"highlight_end":39},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (u16x8) => {","highlight_start":1,"highlight_end":17},{"text":"        impl Shuffle1Dyn for u16x8 {","highlight_start":1,"highlight_end":37},{"text":"            type Indices = Self;","highlight_start":1,"highlight_end":33},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn shuffle1_dyn(self, indices: Self::Indices) -> Self {","highlight_start":1,"highlight_end":68},{"text":"                let indices: u8x8 = (indices * 2).cast();","highlight_start":1,"highlight_end":58},{"text":"                let indices: u8x16 = shuffle!(","highlight_start":1,"highlight_end":47},{"text":"                    indices, [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7]","highlight_start":1,"highlight_end":78},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"                let v = u8x16::new(","highlight_start":1,"highlight_end":36},{"text":"                    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1","highlight_start":1,"highlight_end":67},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"                let indices = indices + v;","highlight_start":1,"highlight_end":43},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    let s: u8x16 =crate::mem::transmute(self);","highlight_start":1,"highlight_end":63},{"text":"                   crate::mem::transmute(s.shuffle1_dyn(indices))","highlight_start":1,"highlight_end":66},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (u32x4) => {","highlight_start":1,"highlight_end":17},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(all(any(target_arch = \"x86\", target_arch = \"x86_64\"),","highlight_start":1,"highlight_end":75},{"text":"                         target_feature = \"avx\"))] {","highlight_start":1,"highlight_end":53},{"text":"                impl Shuffle1Dyn for u32x4 {","highlight_start":1,"highlight_end":45},{"text":"                    type Indices = Self;","highlight_start":1,"highlight_end":41},{"text":"                    #[inline]","highlight_start":1,"highlight_end":30},{"text":"                    fn shuffle1_dyn(self, indices: Self::Indices) -> Self {","highlight_start":1,"highlight_end":76},{"text":"                        #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":52},{"text":"                        use crate::arch::x86::{_mm_permutevar_ps};","highlight_start":1,"highlight_end":67},{"text":"                        #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":55},{"text":"                        use crate::arch::x86_64::{_mm_permutevar_ps};","highlight_start":1,"highlight_end":70},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        unsafe {","highlight_start":1,"highlight_end":33},{"text":"                            crate::mem::transmute(","highlight_start":1,"highlight_end":51},{"text":"                                _mm_permutevar_ps(","highlight_start":1,"highlight_end":51},{"text":"                                    crate::mem::transmute(self.0),","highlight_start":1,"highlight_end":67},{"text":"                                    crate::mem::transmute(indices.0)","highlight_start":1,"highlight_end":69},{"text":"                                )","highlight_start":1,"highlight_end":34},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                impl Shuffle1Dyn for u32x4 {","highlight_start":1,"highlight_end":45},{"text":"                    type Indices = Self;","highlight_start":1,"highlight_end":41},{"text":"                    #[inline]","highlight_start":1,"highlight_end":30},{"text":"                    fn shuffle1_dyn(self, indices: Self::Indices) -> Self {","highlight_start":1,"highlight_end":76},{"text":"                        let indices: u8x4 = (indices * 4).cast();","highlight_start":1,"highlight_end":66},{"text":"                        let indices: u8x16 = shuffle!(","highlight_start":1,"highlight_end":55},{"text":"                            indices,","highlight_start":1,"highlight_end":37},{"text":"                            [0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3]","highlight_start":1,"highlight_end":77},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        let v = u8x16::new(","highlight_start":1,"highlight_end":44},{"text":"                            0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3","highlight_start":1,"highlight_end":75},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        let indices = indices + v;","highlight_start":1,"highlight_end":51},{"text":"                        unsafe {","highlight_start":1,"highlight_end":33},{"text":"                            let s: u8x16 =crate::mem::transmute(self);","highlight_start":1,"highlight_end":71},{"text":"                           crate::mem::transmute(s.shuffle1_dyn(indices))","highlight_start":1,"highlight_end":74},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (u64x2) => {","highlight_start":1,"highlight_end":17},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(all(any(target_arch = \"x86\", target_arch = \"x86_64\"),","highlight_start":1,"highlight_end":75},{"text":"                         target_feature = \"avx\"))] {","highlight_start":1,"highlight_end":53},{"text":"                impl Shuffle1Dyn for u64x2 {","highlight_start":1,"highlight_end":45},{"text":"                    type Indices = Self;","highlight_start":1,"highlight_end":41},{"text":"                    #[inline]","highlight_start":1,"highlight_end":30},{"text":"                    fn shuffle1_dyn(self, indices: Self::Indices) -> Self {","highlight_start":1,"highlight_end":76},{"text":"                        #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":52},{"text":"                        use crate::arch::x86::{_mm_permutevar_pd};","highlight_start":1,"highlight_end":67},{"text":"                        #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":55},{"text":"                        use crate::arch::x86_64::{_mm_permutevar_pd};","highlight_start":1,"highlight_end":70},{"text":"                        // _mm_permutevar_pd uses the _second_ bit of each","highlight_start":1,"highlight_end":75},{"text":"                        // element to perform the selection, that is: 0b00 => 0,","highlight_start":1,"highlight_end":81},{"text":"                        // 0b10 => 1:","highlight_start":1,"highlight_end":38},{"text":"                        let indices = indices << 1;","highlight_start":1,"highlight_end":52},{"text":"                        unsafe {","highlight_start":1,"highlight_end":33},{"text":"                            crate::mem::transmute(","highlight_start":1,"highlight_end":51},{"text":"                                _mm_permutevar_pd(","highlight_start":1,"highlight_end":51},{"text":"                                    crate::mem::transmute(self),","highlight_start":1,"highlight_end":65},{"text":"                                    crate::mem::transmute(indices)","highlight_start":1,"highlight_end":67},{"text":"                                )","highlight_start":1,"highlight_end":34},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                impl Shuffle1Dyn for u64x2 {","highlight_start":1,"highlight_end":45},{"text":"                    type Indices = Self;","highlight_start":1,"highlight_end":41},{"text":"                    #[inline]","highlight_start":1,"highlight_end":30},{"text":"                    fn shuffle1_dyn(self, indices: Self::Indices) -> Self {","highlight_start":1,"highlight_end":76},{"text":"                        let indices: u8x2 = (indices * 8).cast();","highlight_start":1,"highlight_end":66},{"text":"                        let indices: u8x16 = shuffle!(","highlight_start":1,"highlight_end":55},{"text":"                            indices,","highlight_start":1,"highlight_end":37},{"text":"                            [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]","highlight_start":1,"highlight_end":77},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        let v = u8x16::new(","highlight_start":1,"highlight_end":44},{"text":"                            0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7","highlight_start":1,"highlight_end":75},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        let indices = indices + v;","highlight_start":1,"highlight_end":51},{"text":"                        unsafe {","highlight_start":1,"highlight_end":33},{"text":"                            let s: u8x16 =crate::mem::transmute(self);","highlight_start":1,"highlight_end":71},{"text":"                           crate::mem::transmute(s.shuffle1_dyn(indices))","highlight_start":1,"highlight_end":74},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (u128x1) => {","highlight_start":1,"highlight_end":18},{"text":"        impl Shuffle1Dyn for u128x1 {","highlight_start":1,"highlight_end":38},{"text":"            type Indices = Self;","highlight_start":1,"highlight_end":33},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn shuffle1_dyn(self, _indices: Self::Indices) -> Self {","highlight_start":1,"highlight_end":69},{"text":"                self","highlight_start":1,"highlight_end":21},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    ($id:ident) => { impl_fallback!($id); }","highlight_start":1,"highlight_end":44},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"a similar name exists in the module","code":null,"level":"help","spans":[{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/shuffle1_dyn.rs","byte_start":1287,"byte_end":1302,"line_start":40,"line_end":40,"column_start":50,"column_end":65,"is_primary":true,"text":[{"text":"                        use crate::arch::x86_64::_mm_shuffle_pi8;","highlight_start":50,"highlight_end":65}],"label":null,"suggested_replacement":"_mm_shuffle_epi8","suggestion_applicability":"MaybeIncorrect","expansion":{"span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/shuffle1_dyn.rs","byte_start":11980,"byte_end":12004,"line_start":297,"line_end":297,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"impl_shuffle1_dyn!(u8x8);","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_shuffle1_dyn!","def_site_span":{"file_name":"/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/shuffle1_dyn.rs","byte_start":680,"byte_end":11926,"line_start":28,"line_end":293,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_shuffle1_dyn {","highlight_start":1,"highlight_end":33},{"text":"    (u8x8) => {","highlight_start":1,"highlight_end":16},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(all(any(target_arch = \"x86\", target_arch = \"x86_64\"),","highlight_start":1,"highlight_end":75},{"text":"                         target_feature = \"ssse3\"))] {","highlight_start":1,"highlight_end":55},{"text":"                impl Shuffle1Dyn for u8x8 {","highlight_start":1,"highlight_end":44},{"text":"                    type Indices = Self;","highlight_start":1,"highlight_end":41},{"text":"                    #[inline]","highlight_start":1,"highlight_end":30},{"text":"                    fn shuffle1_dyn(self, indices: Self::Indices) -> Self {","highlight_start":1,"highlight_end":76},{"text":"                        #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":52},{"text":"                        use crate::arch::x86::_mm_shuffle_pi8;","highlight_start":1,"highlight_end":63},{"text":"                        #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":55},{"text":"                        use crate::arch::x86_64::_mm_shuffle_pi8;","highlight_start":1,"highlight_end":66},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        unsafe {","highlight_start":1,"highlight_end":33},{"text":"                            crate::mem::transmute(","highlight_start":1,"highlight_end":51},{"text":"                                _mm_shuffle_pi8(","highlight_start":1,"highlight_end":49},{"text":"                                    crate::mem::transmute(self.0),","highlight_start":1,"highlight_end":67},{"text":"                                    crate::mem::transmute(indices.0)","highlight_start":1,"highlight_end":69},{"text":"                                )","highlight_start":1,"highlight_end":34},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            } else if #[cfg(all(","highlight_start":1,"highlight_end":33},{"text":"                any(","highlight_start":1,"highlight_end":21},{"text":"                    all(target_aarch = \"aarch64\", target_feature = \"neon\"),","highlight_start":1,"highlight_end":76},{"text":"                    all(target_aarch = \"arm\", target_feature = \"v7\",","highlight_start":1,"highlight_end":69},{"text":"                        target_feature = \"neon\")","highlight_start":1,"highlight_end":49},{"text":"                ),","highlight_start":1,"highlight_end":19},{"text":"                any(feature = \"core_arch\", libcore_neon)","highlight_start":1,"highlight_end":57},{"text":"            )","highlight_start":1,"highlight_end":14},{"text":"            )] {","highlight_start":1,"highlight_end":17},{"text":"                impl Shuffle1Dyn for u8x8 {","highlight_start":1,"highlight_end":44},{"text":"                    type Indices = Self;","highlight_start":1,"highlight_end":41},{"text":"                    #[inline]","highlight_start":1,"highlight_end":30},{"text":"                    fn shuffle1_dyn(self, indices: Self::Indices) -> Self {","highlight_start":1,"highlight_end":76},{"text":"                        #[cfg(targt_arch = \"aarch64\")]","highlight_start":1,"highlight_end":55},{"text":"                        use crate::arch::aarch64::vtbl1_u8;","highlight_start":1,"highlight_end":60},{"text":"                        #[cfg(targt_arch = \"arm\")]","highlight_start":1,"highlight_end":51},{"text":"                        use crate::arch::arm::vtbl1_u8;","highlight_start":1,"highlight_end":56},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // This is safe because the binary is compiled with","highlight_start":1,"highlight_end":76},{"text":"                        // neon enabled at compile-time and can therefore only","highlight_start":1,"highlight_end":79},{"text":"                        // run on CPUs that have it enabled.","highlight_start":1,"highlight_end":61},{"text":"                        unsafe {","highlight_start":1,"highlight_end":33},{"text":"                            Simd(mem::transmute(","highlight_start":1,"highlight_end":49},{"text":"                                vtbl1_u8(mem::transmute(self.0),","highlight_start":1,"highlight_end":65},{"text":"                                        crate::mem::transmute(indices.0))","highlight_start":1,"highlight_end":74},{"text":"                            ))","highlight_start":1,"highlight_end":31},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                impl_fallback!(u8x8);","highlight_start":1,"highlight_end":38},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (u8x16) => {","highlight_start":1,"highlight_end":17},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(all(any(target_arch = \"x86\", target_arch = \"x86_64\"),","highlight_start":1,"highlight_end":75},{"text":"                         target_feature = \"ssse3\"))] {","highlight_start":1,"highlight_end":55},{"text":"                impl Shuffle1Dyn for u8x16 {","highlight_start":1,"highlight_end":45},{"text":"                    type Indices = Self;","highlight_start":1,"highlight_end":41},{"text":"                    #[inline]","highlight_start":1,"highlight_end":30},{"text":"                    fn shuffle1_dyn(self, indices: Self::Indices) -> Self {","highlight_start":1,"highlight_end":76},{"text":"                        #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":52},{"text":"                        use crate::arch::x86::_mm_shuffle_epi8;","highlight_start":1,"highlight_end":64},{"text":"                        #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":55},{"text":"                        use crate::arch::x86_64::_mm_shuffle_epi8;","highlight_start":1,"highlight_end":67},{"text":"                        // This is safe because the binary is compiled with","highlight_start":1,"highlight_end":76},{"text":"                        // ssse3 enabled at compile-time and can therefore only","highlight_start":1,"highlight_end":80},{"text":"                        // run on CPUs that have it enabled.","highlight_start":1,"highlight_end":61},{"text":"                        unsafe {","highlight_start":1,"highlight_end":33},{"text":"                            Simd(mem::transmute(","highlight_start":1,"highlight_end":49},{"text":"                                _mm_shuffle_epi8(mem::transmute(self.0),","highlight_start":1,"highlight_end":73},{"text":"                                                crate::mem::transmute(indices))","highlight_start":1,"highlight_end":80},{"text":"                            ))","highlight_start":1,"highlight_end":31},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            } else if #[cfg(all(target_aarch = \"aarch64\", target_feature = \"neon\",","highlight_start":1,"highlight_end":83},{"text":"                                any(feature = \"core_arch\", libcore_neon)))] {","highlight_start":1,"highlight_end":78},{"text":"                impl Shuffle1Dyn for u8x16 {","highlight_start":1,"highlight_end":45},{"text":"                    type Indices = Self;","highlight_start":1,"highlight_end":41},{"text":"                    #[inline]","highlight_start":1,"highlight_end":30},{"text":"                    fn shuffle1_dyn(self, indices: Self::Indices) -> Self {","highlight_start":1,"highlight_end":76},{"text":"                        use crate::arch::aarch64::vqtbl1q_u8;","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // This is safe because the binary is compiled with","highlight_start":1,"highlight_end":76},{"text":"                        // neon enabled at compile-time and can therefore only","highlight_start":1,"highlight_end":79},{"text":"                        // run on CPUs that have it enabled.","highlight_start":1,"highlight_end":61},{"text":"                        unsafe {","highlight_start":1,"highlight_end":33},{"text":"                            Simd(mem::transmute(","highlight_start":1,"highlight_end":49},{"text":"                                vqtbl1q_u8(mem::transmute(self.0),","highlight_start":1,"highlight_end":67},{"text":"                                          crate::mem::transmute(indices.0))","highlight_start":1,"highlight_end":76},{"text":"                            ))","highlight_start":1,"highlight_end":31},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            } else if #[cfg(all(target_aarch = \"arm\", target_feature = \"v7\",","highlight_start":1,"highlight_end":77},{"text":"                                target_feature = \"neon\",","highlight_start":1,"highlight_end":57},{"text":"                                any(feature = \"core_arch\", libcore_neon)))] {","highlight_start":1,"highlight_end":78},{"text":"                impl Shuffle1Dyn for u8x16 {","highlight_start":1,"highlight_end":45},{"text":"                    type Indices = Self;","highlight_start":1,"highlight_end":41},{"text":"                    #[inline]","highlight_start":1,"highlight_end":30},{"text":"                    fn shuffle1_dyn(self, indices: Self::Indices) -> Self {","highlight_start":1,"highlight_end":76},{"text":"                        use crate::arch::arm::vtbl2_u8;","highlight_start":1,"highlight_end":56},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // This is safe because the binary is compiled with","highlight_start":1,"highlight_end":76},{"text":"                        // neon enabled at compile-time and can therefore only","highlight_start":1,"highlight_end":79},{"text":"                        // run on CPUs that have it enabled.","highlight_start":1,"highlight_end":61},{"text":"                        unsafe {","highlight_start":1,"highlight_end":33},{"text":"                            union U {","highlight_start":1,"highlight_end":38},{"text":"                                j: u8x16,","highlight_start":1,"highlight_end":42},{"text":"                                s: (u8x8, u8x8),","highlight_start":1,"highlight_end":49},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let (i0, i1) = U { j: y }.s;","highlight_start":1,"highlight_end":57},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let r0 = vtbl2_u8(","highlight_start":1,"highlight_end":47},{"text":"                                mem::transmute(x),","highlight_start":1,"highlight_end":51},{"text":"                                crate::mem::transmute(i0)","highlight_start":1,"highlight_end":58},{"text":"                            );","highlight_start":1,"highlight_end":31},{"text":"                            let r1 = vtbl2_u8(","highlight_start":1,"highlight_end":47},{"text":"                                mem::transmute(x),","highlight_start":1,"highlight_end":51},{"text":"                                crate::mem::transmute(i1)","highlight_start":1,"highlight_end":58},{"text":"                            );","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let r = U { s: (r0, r1) }.j;","highlight_start":1,"highlight_end":57},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            Simd(mem::transmute(r))","highlight_start":1,"highlight_end":52},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                impl_fallback!(u8x16);","highlight_start":1,"highlight_end":39},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (u16x8) => {","highlight_start":1,"highlight_end":17},{"text":"        impl Shuffle1Dyn for u16x8 {","highlight_start":1,"highlight_end":37},{"text":"            type Indices = Self;","highlight_start":1,"highlight_end":33},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn shuffle1_dyn(self, indices: Self::Indices) -> Self {","highlight_start":1,"highlight_end":68},{"text":"                let indices: u8x8 = (indices * 2).cast();","highlight_start":1,"highlight_end":58},{"text":"                let indices: u8x16 = shuffle!(","highlight_start":1,"highlight_end":47},{"text":"                    indices, [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7]","highlight_start":1,"highlight_end":78},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"                let v = u8x16::new(","highlight_start":1,"highlight_end":36},{"text":"                    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1","highlight_start":1,"highlight_end":67},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"                let indices = indices + v;","highlight_start":1,"highlight_end":43},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    let s: u8x16 =crate::mem::transmute(self);","highlight_start":1,"highlight_end":63},{"text":"                   crate::mem::transmute(s.shuffle1_dyn(indices))","highlight_start":1,"highlight_end":66},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (u32x4) => {","highlight_start":1,"highlight_end":17},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(all(any(target_arch = \"x86\", target_arch = \"x86_64\"),","highlight_start":1,"highlight_end":75},{"text":"                         target_feature = \"avx\"))] {","highlight_start":1,"highlight_end":53},{"text":"                impl Shuffle1Dyn for u32x4 {","highlight_start":1,"highlight_end":45},{"text":"                    type Indices = Self;","highlight_start":1,"highlight_end":41},{"text":"                    #[inline]","highlight_start":1,"highlight_end":30},{"text":"                    fn shuffle1_dyn(self, indices: Self::Indices) -> Self {","highlight_start":1,"highlight_end":76},{"text":"                        #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":52},{"text":"                        use crate::arch::x86::{_mm_permutevar_ps};","highlight_start":1,"highlight_end":67},{"text":"                        #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":55},{"text":"                        use crate::arch::x86_64::{_mm_permutevar_ps};","highlight_start":1,"highlight_end":70},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        unsafe {","highlight_start":1,"highlight_end":33},{"text":"                            crate::mem::transmute(","highlight_start":1,"highlight_end":51},{"text":"                                _mm_permutevar_ps(","highlight_start":1,"highlight_end":51},{"text":"                                    crate::mem::transmute(self.0),","highlight_start":1,"highlight_end":67},{"text":"                                    crate::mem::transmute(indices.0)","highlight_start":1,"highlight_end":69},{"text":"                                )","highlight_start":1,"highlight_end":34},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                impl Shuffle1Dyn for u32x4 {","highlight_start":1,"highlight_end":45},{"text":"                    type Indices = Self;","highlight_start":1,"highlight_end":41},{"text":"                    #[inline]","highlight_start":1,"highlight_end":30},{"text":"                    fn shuffle1_dyn(self, indices: Self::Indices) -> Self {","highlight_start":1,"highlight_end":76},{"text":"                        let indices: u8x4 = (indices * 4).cast();","highlight_start":1,"highlight_end":66},{"text":"                        let indices: u8x16 = shuffle!(","highlight_start":1,"highlight_end":55},{"text":"                            indices,","highlight_start":1,"highlight_end":37},{"text":"                            [0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3]","highlight_start":1,"highlight_end":77},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        let v = u8x16::new(","highlight_start":1,"highlight_end":44},{"text":"                            0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3","highlight_start":1,"highlight_end":75},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        let indices = indices + v;","highlight_start":1,"highlight_end":51},{"text":"                        unsafe {","highlight_start":1,"highlight_end":33},{"text":"                            let s: u8x16 =crate::mem::transmute(self);","highlight_start":1,"highlight_end":71},{"text":"                           crate::mem::transmute(s.shuffle1_dyn(indices))","highlight_start":1,"highlight_end":74},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (u64x2) => {","highlight_start":1,"highlight_end":17},{"text":"        cfg_if! {","highlight_start":1,"highlight_end":18},{"text":"            if #[cfg(all(any(target_arch = \"x86\", target_arch = \"x86_64\"),","highlight_start":1,"highlight_end":75},{"text":"                         target_feature = \"avx\"))] {","highlight_start":1,"highlight_end":53},{"text":"                impl Shuffle1Dyn for u64x2 {","highlight_start":1,"highlight_end":45},{"text":"                    type Indices = Self;","highlight_start":1,"highlight_end":41},{"text":"                    #[inline]","highlight_start":1,"highlight_end":30},{"text":"                    fn shuffle1_dyn(self, indices: Self::Indices) -> Self {","highlight_start":1,"highlight_end":76},{"text":"                        #[cfg(target_arch = \"x86\")]","highlight_start":1,"highlight_end":52},{"text":"                        use crate::arch::x86::{_mm_permutevar_pd};","highlight_start":1,"highlight_end":67},{"text":"                        #[cfg(target_arch = \"x86_64\")]","highlight_start":1,"highlight_end":55},{"text":"                        use crate::arch::x86_64::{_mm_permutevar_pd};","highlight_start":1,"highlight_end":70},{"text":"                        // _mm_permutevar_pd uses the _second_ bit of each","highlight_start":1,"highlight_end":75},{"text":"                        // element to perform the selection, that is: 0b00 => 0,","highlight_start":1,"highlight_end":81},{"text":"                        // 0b10 => 1:","highlight_start":1,"highlight_end":38},{"text":"                        let indices = indices << 1;","highlight_start":1,"highlight_end":52},{"text":"                        unsafe {","highlight_start":1,"highlight_end":33},{"text":"                            crate::mem::transmute(","highlight_start":1,"highlight_end":51},{"text":"                                _mm_permutevar_pd(","highlight_start":1,"highlight_end":51},{"text":"                                    crate::mem::transmute(self),","highlight_start":1,"highlight_end":65},{"text":"                                    crate::mem::transmute(indices)","highlight_start":1,"highlight_end":67},{"text":"                                )","highlight_start":1,"highlight_end":34},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                impl Shuffle1Dyn for u64x2 {","highlight_start":1,"highlight_end":45},{"text":"                    type Indices = Self;","highlight_start":1,"highlight_end":41},{"text":"                    #[inline]","highlight_start":1,"highlight_end":30},{"text":"                    fn shuffle1_dyn(self, indices: Self::Indices) -> Self {","highlight_start":1,"highlight_end":76},{"text":"                        let indices: u8x2 = (indices * 8).cast();","highlight_start":1,"highlight_end":66},{"text":"                        let indices: u8x16 = shuffle!(","highlight_start":1,"highlight_end":55},{"text":"                            indices,","highlight_start":1,"highlight_end":37},{"text":"                            [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]","highlight_start":1,"highlight_end":77},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        let v = u8x16::new(","highlight_start":1,"highlight_end":44},{"text":"                            0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7","highlight_start":1,"highlight_end":75},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        let indices = indices + v;","highlight_start":1,"highlight_end":51},{"text":"                        unsafe {","highlight_start":1,"highlight_end":33},{"text":"                            let s: u8x16 =crate::mem::transmute(self);","highlight_start":1,"highlight_end":71},{"text":"                           crate::mem::transmute(s.shuffle1_dyn(indices))","highlight_start":1,"highlight_end":74},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (u128x1) => {","highlight_start":1,"highlight_end":18},{"text":"        impl Shuffle1Dyn for u128x1 {","highlight_start":1,"highlight_end":38},{"text":"            type Indices = Self;","highlight_start":1,"highlight_end":33},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn shuffle1_dyn(self, _indices: Self::Indices) -> Self {","highlight_start":1,"highlight_end":69},{"text":"                self","highlight_start":1,"highlight_end":21},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    ($id:ident) => { impl_fallback!($id); }","highlight_start":1,"highlight_end":44},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m\u001b[1m: unresolved import `crate::arch::x86_64::_mm_shuffle_pi8`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lixiang/.cargo/registry/src/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/packed_simd-0.3.3/src/codegen/shuffle1_dyn.rs:40:29\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m40\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        use crate::arch::x86_64::_mm_shuffle_pi8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: a similar name exists in the module: `_mm_shuffle_epi8`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno `_mm_shuffle_pi8` in `core_arch::arch::x86_64`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m297\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mimpl_shuffle1_dyn!(u8x8);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `impl_shuffle1_dyn` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"aborting due to 8 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 8 previous errors\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0432, E0557.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0432, E0557.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0432`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0432`.\u001b[0m\n"}
